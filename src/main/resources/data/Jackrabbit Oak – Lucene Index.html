<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/markdown/query/lucene.md at 2024-06-11
 | Rendered using Apache Maven Fluido Skin 1.11.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>Jackrabbit Oak &#x2013; Lucene Index</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.11.1.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script src="../js/apache-maven-fluido-1.11.1.min.js"></script>

    <!-- Matomo -->
    <script>
        var _paq = window._paq = window._paq || [];
                _paq.push(['disableCookies']);
                    _paq.push(['trackPageView']);
                    _paq.push(['enableLinkTracking']);
        
        (function() {
            var u="https://analytics.apache.org";
            _paq.push(['setTrackerUrl', u+'/matomo.php']);
            _paq.push(['setSiteId', '4']);
            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
            g.async=true; g.src=u+'/matomo.js'; s.parentNode.insertBefore(g,s);
        })();
    </script>
    <!-- End Matomo Code -->
  </head>
  <body class="topBarEnabled">
    <a class="github-fork-ribbon right-top" href="https://github.com/apache/jackrabbit-oak" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
    <header id="topbar" class="navbar navbar-fixed-top ">
      <div class="navbar-inner">
        <div class="container-fluid">
        <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
<a class="brand" href="../"  title="Oak logo"><img src="../oak_logo.png" alt="Oak logo" />
</a>
            <ul class="nav">
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Overview <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../index.html" title="Jackrabbit Oak">Jackrabbit Oak</a></li>
            <li><a href="../license.html" title="License">License</a></li>
            <li><a href="../downloads.html" title="Downloads">Downloads</a></li>
            <li><a href="../roadmap.html" title="Roadmap">Roadmap</a></li>
            <li><a href="../articles.html" title="Articles">Articles</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Concepts and Architecture <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../architecture/overview.html" title="Overview">Overview</a></li>
            <li><a href="../architecture/nodestate.html" title="The Node State Model">The Node State Model</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Main APIs <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="https://s.apache.org/jcr-2.0-spec/index.html" title="JCR API">JCR API</a></li>
            <li><a href="https://jackrabbit.apache.org/jcr/jcr-api.html" title="Jackrabbit API">Jackrabbit API</a></li>
            <li><a href="../oak_api/overview.html" title="Oak API">Oak API</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Features and Plugins <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li class="dropdown-submenu">
<a href="../nodestore/overview.html" title="Node Storage">Node Storage</a>
              <ul class="dropdown-menu">
                  <li><a href="../nodestore/documentmk.html" title="Document NodeStore">Document NodeStore</a></li>
                  <li><a href="../nodestore/segment/overview.html" title="Segment NodeStore">Segment NodeStore</a></li>
                  <li><a href="../nodestore/compositens.html" title="Composite NodeStore">Composite NodeStore</a></li>
              </ul>
            </li>
            <li class="dropdown-submenu">
<a href="../plugins/blobstore.html" title="Blob Storage">Blob Storage</a>
              <ul class="dropdown-menu">
                  <li><a href="../features/direct-binary-access.html" title="Direct Binary Access">Direct Binary Access</a></li>
                  <li><a href="../features/direct-binary-access-upload-file.html" title="Direct Binary Access Upload File">Direct Binary Access Upload File</a></li>
              </ul>
            </li>
            <li class="dropdown-submenu">
<a href="../query/query.html" title="Query">Query</a>
              <ul class="dropdown-menu">
                  <li><a href="../query/query-engine.html" title="Query Engine">Query Engine</a></li>
                  <li><a href="../query/grammar-xpath.html" title="XPath Grammar">XPath Grammar</a></li>
                  <li><a href="../query/grammar-sql2.html" title="SQL-2 Grammar">SQL-2 Grammar</a></li>
                  <li><a href="../query/query-troubleshooting.html" title="Troubleshooting">Troubleshooting</a></li>
                  <li><a href="../query/indexing.html" title="Indexing">Indexing</a></li>
                  <li><a href="../query/oak-run-indexing.html" title="Indexing with Oak-Run">Indexing with Oak-Run</a></li>
                  <li><a title="Lucene Index">Lucene Index</a></li>
                  <li><a href="../query/elastic.html" title="Elastic Index">Elastic Index</a></li>
                  <li><a href="../query/property-index.html" title="Property Index">Property Index</a></li>
                  <li><a href="../query/hybrid-index.html" title="Hybrid Index">Hybrid Index</a></li>
                  <li><a href="../query/solr.html" title="Solr Index">Solr Index</a></li>
              </ul>
            </li>
            <li class="dropdown-submenu">
<a href="../security/overview.html" title="Security">Security</a>
              <ul class="dropdown-menu">
                  <li><a href="../security/introduction.html" title="Introduction">Introduction</a></li>
                  <li><a href="../security/reports.html" title="Reports">Reports</a></li>
                  <li><a href="../security/authentication.html" title="Authentication">Authentication</a></li>
                  <li><a href="../security/authorization.html" title="Authorization">Authorization</a></li>
                  <li><a href="../security/principal.html" title="Principal Management">Principal Management</a></li>
                  <li><a href="../security/user.html" title="User Management">User Management</a></li>
              </ul>
            </li>
            <li><a href="../features/atomic-counter.html" title="Atomic Counter">Atomic Counter</a></li>
            <li><a href="../features/observation.html" title="Observation">Observation</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Using Oak <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../use_getting_started.html" title="Getting Started">Getting Started</a></li>
            <li><a href="../construct.html" title="Repository Construction">Repository Construction</a></li>
            <li><a href="../osgi_config.html" title="Configuring Oak">Configuring Oak</a></li>
            <li><a href="../command_line.html" title="Command Line Tools">Command Line Tools</a></li>
            <li><a href="../migration.html" title="Migration">Migration</a></li>
            <li><a href="../differences.html" title="Differences to Jackrabbit 2">Differences to Jackrabbit 2</a></li>
            <li><a href="../known_issues.html" title="Known Issues">Known Issues</a></li>
            <li><a href="../constraints.html" title="Constraints">Constraints</a></li>
            <li><a href="../dos_and_donts.html" title="Dos and Don'ts">Dos and Don'ts</a></li>
            <li><a href="../coldstandby/coldstandby.html" title="Cold Standby">Cold Standby</a></li>
            <li><a href="../FAQ.html" title="FAQ">FAQ</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Developing Oak <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../dev_getting_started.html" title="Getting Started">Getting Started</a></li>
            <li><a href="../participating.html" title="Participating">Participating</a></li>
            <li><a href="../testing.html" title="Testing">Testing</a></li>
            <li><a href="../oakathons.html" title="Oakathons">Oakathons</a></li>
            <li><a href="../developing-with-git.html" title="Developing with Git">Developing with Git</a></li>
            <li><a href="../diagnostic-builds.html" title="Cutting diagnostic builds">Cutting diagnostic builds</a></li>
            <li><a href="../branching.html" title="Branching off a new stable">Branching off a new stable</a></li>
            <li><a href="../attribution.html" title="Attribution">Attribution</a></li>
            <li><a href="../release-schedule.html" title="Release Schedule">Release Schedule</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Links <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="http://jackrabbit.apache.org/oak" title="Apache Jackrabbit Oak">Apache Jackrabbit Oak</a></li>
            <li><a href="http://jackrabbit.apache.org/" title="Apache Jackrabbit">Apache Jackrabbit</a></li>
        </ul>
      </li>
            </ul>
        </div>
      </div>
    </header>
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>Oak Documentation</h1>
</div>
</div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
      <li class=""><a href="https://jackrabbit.apache.org/" class="externalLink" title="Jackrabbit">Jackrabbit</a><span class="divider">/</span></li>
      <li class=""><a href="https://jackrabbit.apache.org/oak/docs/" class="externalLink" title="Oak">Oak</a><span class="divider">/</span></li>
    <li class="active ">Lucene Index <a href="https://github.com/apache/jackrabbit-oak/edit/trunk/oak-doc/src/site/markdown/query/lucene.md"><img src="../images/accessories-text-editor.png" title="Edit" /></a></li>
        <li id="publishDate" class="pull-right">Last Published: 2024-06-11</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li><a href="../index.html" title="Jackrabbit Oak"><span class="none"></span>Jackrabbit Oak</a></li>
    <li><a href="../license.html" title="License"><span class="none"></span>License</a></li>
    <li><a href="../downloads.html" title="Downloads"><span class="none"></span>Downloads</a></li>
    <li><a href="../roadmap.html" title="Roadmap"><span class="none"></span>Roadmap</a></li>
    <li><a href="../articles.html" title="Articles"><span class="none"></span>Articles</a></li>
   <li class="nav-header">Concepts and Architecture</li>
    <li><a href="../architecture/overview.html" title="Overview"><span class="none"></span>Overview</a></li>
    <li><a href="../architecture/nodestate.html" title="The Node State Model"><span class="none"></span>The Node State Model</a></li>
   <li class="nav-header">Main APIs</li>
    <li><a href="https://s.apache.org/jcr-2.0-spec/index.html" class="externalLink" title="JCR API"><span class="none"></span>JCR API</a></li>
    <li><a href="https://jackrabbit.apache.org/jcr/jcr-api.html" class="externalLink" title="Jackrabbit API"><span class="none"></span>Jackrabbit API</a></li>
    <li><a href="../oak_api/overview.html" title="Oak API"><span class="none"></span>Oak API</a></li>
   <li class="nav-header">Features and Plugins</li>
    <li><a href="../nodestore/overview.html" title="Node Storage"><span class="icon-chevron-down"></span>Node Storage</a>
     <ul class="nav nav-list">
      <li><a href="../nodestore/documentmk.html" title="Document NodeStore"><span class="icon-chevron-down"></span>Document NodeStore</a>
       <ul class="nav nav-list">
        <li><a href="../nodestore/document/mongo-document-store.html" title="MongoDB DocumentStore"><span class="none"></span>MongoDB DocumentStore</a></li>
        <li><a href="../nodestore/document/rdb-document-store.html" title="RDB DocumentStore"><span class="none"></span>RDB DocumentStore</a></li>
        <li><a href="../nodestore/document/node-bundling.html" title="Node Bundling"><span class="none"></span>Node Bundling</a></li>
        <li><a href="../nodestore/document/secondary-store.html" title="Secondary Store"><span class="none"></span>Secondary Store</a></li>
        <li><a href="../nodestore/persistent-cache.html" title="Persistent Cache"><span class="none"></span>Persistent Cache</a></li>
        <li><a href="../clustering.html" title="Clustering"><span class="none"></span>Clustering</a></li>
       </ul></li>
      <li><a href="../nodestore/segment/overview.html" title="Segment NodeStore"><span class="none"></span>Segment NodeStore</a></li>
      <li><a href="../nodestore/compositens.html" title="Composite NodeStore"><span class="none"></span>Composite NodeStore</a></li>
     </ul></li>
    <li><a href="../plugins/blobstore.html" title="Blob Storage"><span class="icon-chevron-down"></span>Blob Storage</a>
     <ul class="nav nav-list">
      <li><a href="../features/direct-binary-access.html" title="Direct Binary Access"><span class="none"></span>Direct Binary Access</a></li>
      <li><a href="../features/direct-binary-access-upload-file.html" title="Direct Binary Access Upload File"><span class="none"></span>Direct Binary Access Upload File</a></li>
     </ul></li>
    <li><a href="../query/query.html" title="Query"><span class="icon-chevron-down"></span>Query</a>
     <ul class="nav nav-list">
      <li><a href="../query/query-engine.html" title="Query Engine"><span class="none"></span>Query Engine</a></li>
      <li><a href="../query/grammar-xpath.html" title="XPath Grammar"><span class="none"></span>XPath Grammar</a></li>
      <li><a href="../query/grammar-sql2.html" title="SQL-2 Grammar"><span class="none"></span>SQL-2 Grammar</a></li>
      <li><a href="../query/query-troubleshooting.html" title="Troubleshooting"><span class="none"></span>Troubleshooting</a></li>
      <li><a href="../query/indexing.html" title="Indexing"><span class="none"></span>Indexing</a></li>
      <li><a href="../query/oak-run-indexing.html" title="Indexing with Oak-Run"><span class="none"></span>Indexing with Oak-Run</a></li>
      <li class="active"><a><span class="none"></span>Lucene Index</a></li>
      <li><a href="../query/elastic.html" title="Elastic Index"><span class="none"></span>Elastic Index</a></li>
      <li><a href="../query/property-index.html" title="Property Index"><span class="none"></span>Property Index</a></li>
      <li><a href="../query/hybrid-index.html" title="Hybrid Index"><span class="none"></span>Hybrid Index</a></li>
      <li><a href="../query/solr.html" title="Solr Index"><span class="none"></span>Solr Index</a></li>
     </ul></li>
    <li><a href="../security/overview.html" title="Security"><span class="icon-chevron-down"></span>Security</a>
     <ul class="nav nav-list">
      <li><a href="../security/introduction.html" title="Introduction"><span class="none"></span>Introduction</a></li>
      <li><a href="../security/reports.html" title="Reports"><span class="none"></span>Reports</a></li>
      <li><a href="../security/authentication.html" title="Authentication"><span class="icon-chevron-right"></span>Authentication</a></li>
      <li><a href="../security/authorization.html" title="Authorization"><span class="icon-chevron-right"></span>Authorization</a></li>
      <li><a href="../security/principal.html" title="Principal Management"><span class="icon-chevron-right"></span>Principal Management</a></li>
      <li><a href="../security/user.html" title="User Management"><span class="icon-chevron-right"></span>User Management</a></li>
     </ul></li>
    <li><a href="../features/atomic-counter.html" title="Atomic Counter"><span class="none"></span>Atomic Counter</a></li>
    <li><a href="../features/observation.html" title="Observation"><span class="none"></span>Observation</a></li>
   <li class="nav-header">Using Oak</li>
    <li><a href="../use_getting_started.html" title="Getting Started"><span class="none"></span>Getting Started</a></li>
    <li><a href="../construct.html" title="Repository Construction"><span class="none"></span>Repository Construction</a></li>
    <li><a href="../osgi_config.html" title="Configuring Oak"><span class="none"></span>Configuring Oak</a></li>
    <li><a href="../command_line.html" title="Command Line Tools"><span class="none"></span>Command Line Tools</a></li>
    <li><a href="../migration.html" title="Migration"><span class="none"></span>Migration</a></li>
    <li><a href="../differences.html" title="Differences to Jackrabbit 2"><span class="none"></span>Differences to Jackrabbit 2</a></li>
    <li><a href="../known_issues.html" title="Known Issues"><span class="none"></span>Known Issues</a></li>
    <li><a href="../constraints.html" title="Constraints"><span class="none"></span>Constraints</a></li>
    <li><a href="../dos_and_donts.html" title="Dos and Don'ts"><span class="none"></span>Dos and Don'ts</a></li>
    <li><a href="../coldstandby/coldstandby.html" title="Cold Standby"><span class="none"></span>Cold Standby</a></li>
    <li><a href="../FAQ.html" title="FAQ"><span class="none"></span>FAQ</a></li>
   <li class="nav-header">Developing Oak</li>
    <li><a href="../dev_getting_started.html" title="Getting Started"><span class="none"></span>Getting Started</a></li>
    <li><a href="../participating.html" title="Participating"><span class="none"></span>Participating</a></li>
    <li><a href="../testing.html" title="Testing"><span class="none"></span>Testing</a></li>
    <li><a href="../oakathons.html" title="Oakathons"><span class="none"></span>Oakathons</a></li>
    <li><a href="../developing-with-git.html" title="Developing with Git"><span class="none"></span>Developing with Git</a></li>
    <li><a href="../diagnostic-builds.html" title="Cutting diagnostic builds"><span class="none"></span>Cutting diagnostic builds</a></li>
    <li><a href="../branching.html" title="Branching off a new stable"><span class="none"></span>Branching off a new stable</a></li>
    <li><a href="../attribution.html" title="Attribution"><span class="none"></span>Attribution</a></li>
    <li><a href="../release-schedule.html" title="Release Schedule"><span class="none"></span>Release Schedule</a></li>
   <li class="nav-header">Links</li>
    <li><a href="http://jackrabbit.apache.org/oak" class="externalLink" title="Apache Jackrabbit Oak"><span class="none"></span>Apache Jackrabbit Oak</a></li>
    <li><a href="http://jackrabbit.apache.org/" class="externalLink" title="Apache Jackrabbit"><span class="none"></span>Apache Jackrabbit</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
<form id="search-form" action="https://www.google.com/search" method="get" >
  <input value="jackrabbit.apache.org/oak/docs/" name="sitesearch" type="hidden"/>
  <input class="search-query" name="q" id="query" type="text" placeholder="Search with Google..." />
</form>
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
  -->
<section>
<h2><a name="Lucene_Index"></a>Lucene Index</h2>
<ul>

<li><a href="#new-1.6">New in 1.6</a></li>
<li><a href="#index-definition">Index Definition</a>
<ul>

<li><a href="#indexing-rules">Indexing Rules</a>
<ul>

<li><a href="#cost-overrides">Cost Overrides</a></li>
<li><a href="#indexing-rule-inheritence">Indexing Rule inheritance</a></li>
<li><a href="#property-definitions">Property Definitions</a></li>
<li><a href="#path-restrictions">Evaluate Path Restrictions</a></li>
<li><a href="#include-exclude">Include and Exclude paths from indexing</a></li>
</ul>
</li>
<li><a href="#aggregation">Aggregation</a></li>
<li><a href="#analyzers">Analyzers</a>
<ul>

<li><a href="#analyzer-classes">Specify analyzer class directly</a></li>
<li><a href="#analyzer-composition">Create analyzer via composition</a></li>
</ul>
</li>
<li><a href="#codec">Codec</a></li>
<li><a href="#boost">Boost and Search Relevancy</a></li>
<li><a href="#stored-index-definition">Effective Index Definition</a></li>
<li><a href="#generate-index-definition">Generating Index Definition</a></li>
</ul>
</li>
<li><a href="#nrt-indexing">Near Real Time Indexing</a></li>
<li><a href="#osgi-config">LuceneIndexProvider Configuration</a></li>
<li><a href="#tika-config">Tika Config</a>
<ul>

<li><a href="#mime-type-usage">Mime type usage</a></li>
<li><a href="#mime-type-mapping">Mime type mapping</a></li>
</ul>
</li>
<li><a href="#non-root-index">Non Root Index Definitions</a></li>
<li><a href="#function-based-indexing">Function-Based Indexing</a></li>
<li><a href="#dynamic-boost">Dynamic Boost</a></li>
<li><a href="#native-query">Native Query and Index Selection</a></li>
<li><a href="#persisting-indexes">Persisting indexes</a></li>
<li><a href="#copy-on-read">CopyOnRead</a></li>
<li><a href="#copy-on-write">CopyOnWrite</a></li>
<li><a href="#mbeans">Lucene Index MBeans</a></li>
<li><a href="#active-blob-collection">Active Index Files Collection</a></li>
<li><a href="#luke">Analyzing created Lucene Index</a></li>
<li><a href="#text-extraction">Pre-Extracting Text from Binaries</a></li>
<li><a href="#advanced-search-features">Advanced search features</a>
<ul>

<li><a href="#suggestions">Suggestions</a></li>
<li><a href="#spellchecking">Spellchecking</a></li>
<li><a href="#facets">Facets</a></li>
<li><a href="#score-explanation">Score Explanation</a></li>
<li><a href="#custom-hooks">Custom hooks</a></li>
<li><a href="#similar-fv">Search by similar feature vectors</a></li>
</ul>
</li>
<li><a href="#design-considerations">Design Considerations</a></li>
<li><a href="#limits">Limits</a></li>
<li><a href="#lucene-vs-property">Lucene Index vs Property Index</a></li>
<li><a href="#examples">Examples</a>
<ul>

<li><a href="#simple-queries">A - Simple queries</a></li>
<li><a href="#queries-structured-content">B - Queries for structured content</a>
<ul>

<li><a href="#uc1">UC1 - Find all assets which are having <code>status</code> as <code>published</code></a></li>
<li><a href="#uc2">UC2 - Find all assets which are having <code>status</code> as <code>published</code> sorted by last modified date</a></li>
<li><a href="#uc3">UC3 - Find all assets where comment contains <i>december</i></a></li>
<li><a href="#uc4">UC4 - Find all assets which are created by David and refer to december</a></li>
<li><a href="#uc5">UC5 - Facets</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Oak supports Lucene based indexes to support both property constraint and full
text constraints. Depending on the configuration a Lucene index can be used
to evaluate property constraints, full text constraints, path restrictions
and sorting.</p>

<div class="source"><pre class="prettyprint"><code>SELECT * FROM [nt:base] WHERE [assetType] = 'image'
</code></pre></div>
<p>Following index definition would allow using Lucene index for above query</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - type = &quot;lucene&quot;
  - compatVersion = 2
  - async = &quot;async&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + assetType
          - propertyIndex = true
          - name = &quot;assetType&quot;
</code></pre></div>
<p>The index definition node for a lucene-based index</p>
<ul>

<li>must be of type <code>oak:QueryIndexDefinition</code></li>
<li>must have the <code>type</code> property set to <b><code>lucene</code></b></li>
<li>must contain the <code>async</code> property set to the value <code>async</code>, this is what
sends the index update process to a background thread</li>
</ul>
<p><i>Note that compared to <a href="query.html#property-index">Property Index</a> Lucene
Property Index is always configured in Async mode hence it might lag behind
in reflecting the current repository state while performing the query</i></p>
<p>Taking another example. To support the following query</p>

<div class="source"><pre class="prettyprint"><code>/jcr:root/content//*[jcr:contains(., 'text')]
</code></pre></div>
<p>The Lucene index needs to be configured to index all properties</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - type = &quot;lucene&quot;
  - compatVersion = 2
  - async = &quot;async&quot;
  - includedPaths = [&quot;/content&quot;]
  - queryPaths = [&quot;/content&quot;]
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + allProps
          - name = &quot;.*&quot;
          - isRegexp = true
          - nodeScopeIndex = true
</code></pre></div><section>
<h3><a name="New_in_1.6"></a><a name="new-1.6"></a> New in 1.6</h3>
<p>Following are the new features in 1.6 release</p>
<ul>

<li><a href="#nrt-indexing">Near Real Time Indexing</a></li>
<li><a href="#stored-index-definition">Effective Index Definition</a></li>
</ul></section><section>
<h3><a name="Index_Definition"></a><a name="index-definition"></a> Index Definition</h3>
<p>Lucene index definition consist of <code>indexingRules</code>, <code>analyzers</code> ,
<code>aggregates</code> etc which determine which node and properties are to be indexed
and how they are indexed.</p>
<p>Below is the canonical index definition structure</p>

<div class="source"><pre class="prettyprint"><code>luceneIndex (oak:QueryIndexDefinition)
  - type (string) = 'lucene' mandatory
  - async (string) = 'async' mandatory
  - codec (string)
  - compatVersion (long) = 2
  - evaluatePathRestrictions (boolean) = false
  - valueRegex (string)
  - queryFilterRegex (string)
  - includedPaths (string) multiple
  - queryPaths (string) multiple = ['/']
  - excludedPaths (string) multiple
  - maxFieldLength (long) = 10000
  - refresh (boolean)
  - useIfExists (string)
  - blobSize (long) = 32768
  - functionName (string)
  - name (string)
  - indexPath (string)
  + indexRules (nt:unstructured)
  + aggregates (nt:unstructured)
  + analyzers (nt:unstructured)
  + tika (nt:unstructured)
</code></pre></div>
<p>Following are the config options which can be defined at the index definition
level</p>
<dl>

<dt>type</dt>
<dd>Required and should always be <code>lucene</code>.</dd>
<dt>async</dt>
<dd>Required and should always be <code>async</code>, or [<code>async</code>, <code>nrt</code>].</dd>
<dt>codec</dt>
<dd>Optional string property.</dd>
<dd>Name of the <a href="#codec">Lucene codec</a> to use</dd>
<dt>compatVersion</dt>
<dd>Required integer property, needs to be set to 2</dd>
<dd>Version 1 is deprecated, and new indexes should always use version 2.
Version 1 doesn't support property restrictions and index time aggregation.
A compatVersion 2 full text index is usually faster to run queries.
For full text indexing with compatVersion 2,
at query time, only the access right of the parent (aggregate) node is checked,
and the access right of the child nodes is not checked.
If this is a concern, then aggregation should not be used.</dd>
<dt>evaluatePathRestrictions</dt>
<dd>Optional boolean property defaults to <code>false</code>.</dd>
<dd>If enabled the index can evaluate <a href="#path-restrictions">path restrictions</a></dd>
<dt>valueRegex</dt>
<dd>Optional string property</dd>
<dd>A regular expression for property value in index definition. If this is specified,
then only those properties would be added to index whose value matches the regex
defined by this property.</dd>
<dt>queryFilterRegex</dt>
<dd>Optional string property</dd>
<dd>A regular expression for query text. If this property is present in an index definition,
then those queries whose search text doesn't match this pattern but are still using the index will log a warning.
If this property is not specified, but valueRegex is specified, that property is also used for the use
case specified here.</dd>
<dt>includedPaths</dt>
<dd>Optional multi value property. Defaults to &#x2018;/&#x2019;.</dd>
<dd>List of paths which should be included in the index.
If used, &#x2018;queryPaths&#x2019; should be set to the same value(s).
See <a href="#include-exclude">Path Includes/Excludes</a> for details.</dd>
<dt>queryPaths</dt>
<dd>Optional multi value property. Defaults to &#x2018;/&#x2019;.</dd>
<dd>List of paths for which the index can be used to perform queries.
If used, &#x2018;includedPaths&#x2019; should be set to the same value(s).
See <a href="#include-exclude">Path Includes/Excludes</a> for details.</dd>
<dt>excludedPaths</dt>
<dd>Optional multi value property. Defaults to empty.</dd>
<dd>List of paths which should be excluded from indexing.
See <a href="#include-exclude">Path Includes/Excludes</a> for details.</dd>
<dt>tags</dt>
<dd>Optional multi value property. Defaults to empty.</dd>
<dd>List of <a class="externalLink" href="https://jackrabbit.apache.org/oak/docs/query/query-engine.html#Query_Option_Index_Tag">tags of this index</a>.</dd>
<dt>selectionPolicy</dt>
<dd>Optional string property. Defaults to empty.</dd>
<dd>The <a class="externalLink" href="https://jackrabbit.apache.org/oak/docs/query/query-engine.html#Index_Selection_Policy">selection policy of this index</a>.</dd>
<dt><a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2469">maxFieldLength</a></dt>
<dd>Numbers of terms indexed per field. Defaults to 10000</dd>
<dt>refresh</dt>
<dd>Optional boolean property.</dd>
<dd>Used to refresh the stored index definition. See <a href="#stored-index-definition">Effective Index Definition</a></dd>
<dt><a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-7739">useIfExists</a></dt>
<dd>Optional string property</dd>
<dd>Only use this index for queries if the given node or property exists.
This is specially useful in blue-green deployments, when using the composite node store.
For example, if set to <code>/libs/indexes/acme/@v1</code>, the index is only used if
the given property exists. With a repository where this property is missing,
the index is not used. With blue-green deployments, it is possible that
two versions of an application are running at the same time, with different <code>/libs</code> folders.
This settings therefore allows to enable or disable index usage depending on the version in use.
(This index is still updated even if the node / property does not exist,
so this setting only affects index usage for queries.)
This option is supported for indexes of type <code>lucene</code> and <code>property</code>.
<code>@since Oak 1.10.0</code></dd>
<dt><a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2201">blobSize</a></dt>
<dd>Default value 32768 (32kb).</dd>
<dd>Size in bytes used for splitting the index files when storing them</dd>
<dt>functionName</dt>
<dd>Name to be used to enable index usage with <a href="#native-query">native query support</a>.</dd>
<dt>name</dt>
<dd>Deprecated. Optional property.</dd>
<dd>Captures the name of the index which is used while logging</dd>
<dt>indexPath</dt>
<dd>Deprecated. Optional string property to specify <a href="#copy-on-write">index path</a>.</dd>
<dd>Path of the index definition in the repository. For e.g. if the index
definition is specified at <code>/oak:index/lucene</code> then set this path in <code>indexPath</code></dd>
</dl><section>
<h4><a name="Indexing_Rules"></a><a name="indexing-rules"></a> Indexing Rules</h4>
<p>Indexing rules define which types of nodes and properties are indexed. An
index configuration can define one or more <code>indexingRules</code> for different
nodeTypes.</p>

<div class="source"><pre class="prettyprint"><code>fulltextIndex
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + app:Page
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + publishedDate
          - propertyIndex = true
          - name = &quot;jcr:content/publishedDate&quot;
    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + imageType
          - propertyIndex = true
          - name = &quot;jcr:content/metadata/imageType&quot;
</code></pre></div>
<p>Rules are defined per nodeType and each rule has one or more property
definitions that determine which properties are indexed. Below is the canonical index
definition structure</p>

<div class="source"><pre class="prettyprint"><code>ruleName (nt:unstructured)
  - inherited (boolean) = true
  - indexNodeName (boolean) = false
  - includePropertyTypes (string) multiple
  + properties (nt:unstructured)
</code></pre></div>
<p>Following are the config options which can be defined at the index rule
level</p>
<dl>

<dt>inherited</dt>
<dd>Optional boolean property defaults to true</dd>
<dd>Determines if the rule is applicable on exact match or can be applied if
match is done on basis of nodeType inheritance</dd>
<dt>includePropertyTypes</dt>
<dd>Applicable when index is enabled for fulltext indexing</dd>
<dd>For full text index defaults to include all types</dd>
<dd>String array of property types which should be indexed. The values can be one
specified in <a class="externalLink" href="https://s.apache.org/jcr-2.0-javadoc/constant-values.html#javax.jcr.PropertyType.TYPENAME_STRING">PropertyType Names</a></dd>
<dt><a name="index-node-name"></a></dt>
<dt>indexNodeName</dt>
<dd><code>@since Oak 1.0.20, 1.2.5</code></dd>
<dd>Default to false. If set to true then index would also be created for node name.
This would enable faster evaluation of queries involving constraints on Node
name. For example
<ul>

<li><i>select [jcr:path] from [nt:base] where NAME() = &#x2018;kite&#x2019;</i></li>
<li><i>select [jcr:path] from [nt:base] where NAME() LIKE &#x2018;kite%&#x2019;</i></li>
<li>/jcr:root//kite</li>
<li>/jcr:root//*[jcr:like(fn:name(), &#x2018;kite%&#x2019;)]</li>
<li>/jcr:root//element(*, app:Asset)[fn:name() = &#x2018;kite&#x2019;]</li>
<li>/jcr:root//element(kite, app:Asset)</li>
</ul>
</dd>
</dl><section>
<h5><a name="Cost_Overrides"></a><a name="cost-overrides"></a> Cost Overrides</h5>
<p>By default, the cost of using this index is calculated follows: For each query,
the overhead is one operation. For each entry in the index, the cost is one.
The following only applies to <code>compatVersion</code> 2 only:
To use a lower or higher cost, you can set the following optional properties
in the index definition:</p>

<div class="source"><pre class="prettyprint"><code>- costPerExecution (Double) = 1.0
- costPerEntry (Double) = 1.0
</code></pre></div>
<p>Please note that typically, those settings don't need to be explicitly set.
Cost per execution is the overhead of one query.
Cost per entry is the cost per node in the index.
Using 0.5 means the cost is half, which means the index would be used more often
(that is, even if there is a different index with similar cost).</p></section><section>
<h5><a name="Indexing_Rule_inheritance"></a><a name="indexing-rule-inheritence"></a>Indexing Rule inheritance</h5>
<p><code>indexRules</code> are defined per nodeType and support nodeType inheritance. For
example while indexing any node the indexer would look up for applicable
indexRule for that node based on its <i>primaryType</i>. If a direct match is
found then that rule would be used otherwise it would look for rule for any
of the parent types. The rules are looked up in the order of there entry
under <code>indexRules</code> node (indexRule node itself is of type <code>nt:unstructured</code>
which has <code>orderable</code> child nodes)</p>
<p>If <code>inherited</code> is set to false on any rule then that rule would only be
applicable if exact match is found</p></section><section>
<h5><a name="Property_Definitions"></a><a name="property-definitions"></a>Property Definitions</h5>
<p>Each index rule consist of one or more property definition defined under
<code>properties</code>. Order of property definition node is important as some properties
are based on regular expressions. Below is the canonical property definition
structure</p>

<div class="source"><pre class="prettyprint"><code>propNode (nt:unstructured)
  - name (string)
  - boost (double) = '1.0'
  - index (boolean) = true
  - useInExcerpt (boolean) = false
  - analyzed (boolean) = false
  - nodeScopeIndex (boolean) = false
  - ordered (boolean) = false
  - isRegexp (boolean) = false
  - type (string) = 'undefined'
  - propertyIndex (boolean) = false
  - notNullCheckEnabled (boolean) = false
  - nullCheckEnabled (boolean) = false
  - excludeFromAggregation (boolean) = false
  - weight (long) = 5
  - function (string)
</code></pre></div>
<p>Following are the details about the above mentioned config options which can be
defined at the property definition level</p>
<dl>

<dt>name</dt>
<dd>Property name. If not defined, then the property name is set to the node name.
<p>Can also be set to a relative property, e.g., <code>jcr:content/metadata/color</code>.
For relative properties, one wildcard (<code>*</code>) is supported instead of a node name:
<code>*/color</code> aggregates the values of the property <code>color</code> of all direct child nodes.</p>
<p>If <code>isRegexp</code> is true, then the property name is a regular expression.</p>
<p>Special properties such as &#x201c;jcr:path&#x201d;, &#x201c;jcr:score&#x201d; can not be indexed.
The path can be indexes using a function-based index in recent versions of Oak.</p></dd>
<dt>isRegexp</dt>
<dd>If set to true, then the property name is interpreted as a regular
expression, and the given definition is applicable for matching property names.
The expression must not match &#x2018;/&#x2019;.
<ul>

<li><code>^[^\/]*$</code> - Matches all properties of this node.</li>
<li><code>jcr:content/metadata/.*</code> - This property definition is
applicable for all properties of the child node <code>jcr:content/metadata</code></li>
</ul>
<p>The regular expression only matches property names, and not intermediate nodes.
<code>jcr:content/.*/.*</code> does <i>not</i> index all properties for all children of
<code>jcr:content</code>. <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-5187">OAK-5187</a> is an open improvement to track supporting
regular expression matching for intermediate child nodes.</p>
</dd>
<dt>boost</dt>
<dd>If the property is included in <code>nodeScopeIndex</code> then it defines the boost
done for the index value against the given property name. See
<a href="#boost">Boost and Search Relevancy</a> for more details</dd>
<dt>index</dt>
<dd>Determines if this property should be indexed. Mostly useful for fulltext
index where some properties need to be <i>excluded</i> from getting indexed.</dd>
<dt>useInExcerpt</dt>
<dd>Controls whether the value of a property should be used to create an excerpt.
The value of the property is still full-text indexed when set to false, but it
will never show up in an excerpt for its parent node. If set to true then
property value would be stored separately within index causing the index
size to increase. So set it to true only if you make use of excerpt feature</dd>
<dt>nodeScopeIndex</dt>
<dd>Control whether the value of a property should be part of fulltext index. That
is, you can do a <i>jcr:contains(., &#x2018;foo&#x2019;)</i> and it will return nodes that have a
string property that contains the word foo. Example
<ul>

<li>/jcr:root/content//element(*, app:Asset)[jcr:contains(., &#x2018;image&#x2019;)]_</li>
</ul>
<p>In case of aggregation all properties would be indexed at node level by default
if the property type is part of <code>includePropertyTypes</code>. However, if there is an
explicit property definition provided then it would only be included if
<code>nodeScopeIndex</code> is set to true.</p>
<p>Note : If an index definition consists of any property with nodeScopeIndex set to
true, then it will index the node name for all the nodes (with node type
matching to or a child type of the one defined in the indexRule).
This could result in large index size in case of indexRules on broader node types such as nt:base.</p>
<p>So it's advisable to use nodeScopeIndex for broader node types only if it's absolutely
needed to support queries like <i>jcr:contains(., &#x2018;foo&#x2019;)</i></p>
</dd>
<dt>analyzed</dt>
<dd>Set this to true if the property is used as part of <code>contains</code>. Example
<ul>

<li>/jcr:root/content//element(*, app:Asset)[jcr:contains(@type, &#x2018;image&#x2019;)]_</li>
<li>/jcr:root/content//element(*, app:Asset)[jcr:contains(jcr:content/metadata/@format, &#x2018;image&#x2019;)]_</li>
</ul>
</dd>
<dt><a name="ordered"></a></dt>
<dt>ordered</dt>
<dd>If the property is to be used in <i>order by</i> clause to perform sorting then
this should be set to true. This should be set to true only if the property
is to be used to perform sorting as it increases the index size. Example
<ul>

<li>/jcr:root/content//element(*, app:Asset)[jcr:contains(@type, &#x2018;image&#x2019;)] order by @size_</li>
<li>/jcr:root/content//element(*, app:Asset)[jcr:contains(@type, &#x2018;image&#x2019;)] order by
jcr:content/@jcr:lastModified_</li>
</ul>
<p>Refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2196">Lucene based Sorting</a> for more details. Note that this is
only supported for single value property. Enabling this on multi value property
would cause indexing to fail.</p>
<p>Ordering is supported on properties, and on functions. To order on the name of the node,
use the following query and index definition:</p>
<p>SELECT * FROM [sling:Folder] WHERE ISCHILDNODE(&#x2018;/content&#x2019;) ORDER BY NAME()</p>
<ul>

<li>sling:Folder
<ul>

<li>properties (nt:unstructured)
<ul>

<li>nodeName (nt:unstructured)
<ul>

<li>function (string) = &#x2018;name()&#x2019;</li>
<li>propertyIndex (boolean) = true</li>
<li>ordered (boolean) = true</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</dd>
<dt>type</dt>
<dd>JCR Property type. Can be one of <code>Date</code>, <code>Boolean</code>, <code>Double</code> , <code>String</code>, <code>Long</code>, or <code>Binary</code>.
Mostly inferred from the indexed value. However in some cases where same property
type is not used consistently across various nodes then it would recommended
to specify the type explicitly.
A binary is only indexed if there is an associated property <code>jcr:mimeType</code>.</dd>
<dt>propertyIndex</dt>
<dd>Whether the index for this property is used for equality conditions, ordering,
and is not null conditions.</dd>
<dt>notNullCheckEnabled</dt>
<dd>Since 1.1.8</dd>
<dd>If the property is checked for <i>is not null</i> then this should be set to true.
To reduce the index size,
this should only be enabled for nodeTypes that are not generic.
<ul>

<li>/jcr:root/content//element(*, app:Asset)[jcr:content/@excludeFromSearch]</li>
</ul>
<p>For details, see <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2234">IS NOT NULL support</a>.</p>
</dd>
<dt>nullCheckEnabled</dt>
<dd>Since 1.0.12</dd>
<dd>If the property is checked for <i>is null</i> then this should be set to true. This
should only be enabled for nodeTypes that are not generic as it leads to index
entry for all nodes of that type where this property is not set.
<ul>

<li>/jcr:root/content//element(*, app:Asset)[not(jcr:content/@excludeFromSearch)]</li>
</ul>
<p>It would be better to use a query which checks for property existence or property
being set to specific values as such queries can make use of index without any
extra storage cost.</p>
<p>For details, see <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2517">IS NULL support</a>.</p>
</dd>
<dt>excludeFromAggregation</dt>
<dd>Since 1.0.27, 1.2.11</dd>
<dd>If set to true, the property is excluded from aggregation <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-3981">OAK-3981</a></dd>
<dt>function</dt>
<dd>Since 1.5.11, 1.6.0, 1.42.0</dd>
<dd>Function, for <a href="#function-based-indexing">function-based indexing</a>.</dd>
<dt>dynamicBoost</dt>
<dd>Since 1.28.0</dd>
<dd>Enable <a href="#dynamic-boost">dynamic boost</a></dd>
<dt><a name="weight"></a></dt>
<dt>weight</dt>
<dd>Allows to override the estimated number of entries per value,
which affects the cost of the index.</dd>
<dd>Since 1.6.3: if <code>weight</code> is set to <code>0</code>, then this property is assumed not to reduce the cost.
Queries that contain <i>only</i> this condition should not use that index.
See <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-5899">OAK-5899</a> for details.</dd>
<dd>Since 1.7.11: if <code>weight</code> is set to <code>10</code>, then the estimated number of unique entries is 10.
This means, the cost is reduced by a factor of about 10, for queries that contain this condition.
See <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-6735">OAK-6735</a> for details.</dd>
<dd>Since 1.10: the default value is now <code>5</code>.
See <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-7379">OAK-7379</a> for details.</dd>
<dt>sync</dt>
<dd>Since 1.8.0, <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-6535">OAK-6535</a></dd>
<dd>Changes to the content are available in the index as soon as they are committed.
Requires &#x201c;propertyIndex=true&#x201d;.
Relative properties and notNullCheckEnabled are not supported.</dd>
<dd>See <a class="externalLink" href="https://jackrabbit.apache.org/oak/docs/query/hybrid-index.html">Hybrid Indexes</a> for details.</dd>
<dt>unique</dt>
<dd>Since 1.8.0, <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-6535">OAK-6535</a></dd>
<dd>Requires &#x201c;sync=true&#x201d;. Enforces unique property values in the content.</dd>
<dd>See <a class="externalLink" href="https://jackrabbit.apache.org/oak/docs/query/hybrid-index.html">Hybrid Indexes</a> for details.</dd>
</dl>
<p><a name="property-names"></a><b>Property Names</b></p>
<p>Property name can be one of following</p>
<ol style="list-style-type: decimal">

<li>Simple name - Like <i>assetType</i> etc. These are used for properties which are
defined directly on the indexed node</li>
<li>Relative name - Like <i>jcr:content/metadata/title</i>. These are used for
properties which are defined relative to the node being indexed.</li>
<li>Regular Expression - Like <i>.*</i>. Used when only property whose name
match given pattern are to be indexed.
They can also be used for relative properties like
<i>jcr:content/metadata/dc:.*$</i>
which indexes all property names starting with <i>dc</i> from node with
relative path <i>jcr:content/metadata</i></li>
<li>The string <code>:nodeName</code> - this special case indexes node name as if it's a
virtual property of the node being indexed. Setting this along with
<code>nodeScopeIndex=true</code> is akin to setting <code>indexNodeName=true</code> on indexing
rule (<code>@since Oak 1.3.15, 1.2.14</code>).
Ordering is not supported. For ordering, use <code>function=name()</code> instead.</li>
</ol></section><section>
<h5><a name="Evaluate_Path_Restrictions"></a><a name="path-restrictions"></a> Evaluate Path Restrictions</h5>
<p>Lucene index provides support for evaluating path restrictions natively.
Consider a query like</p>

<div class="source"><pre class="prettyprint"><code>select * from [app:Asset] as a where isdescendantnode(a, [/content/app/old]) AND contains(*, 'white')
</code></pre></div>
<p>By default, the index would return all node which <i>contain white</i> and Query
engine would filter out nodes which are not under <i>/content/app/old</i>. This
can perform slow if lots of nodes are not under that path. To speed up such
queries one can enable <code>evaluatePathRestrictions</code> in Lucene index and index
would only return nodes which are under <i>/content/app/old</i>.</p>
<p>Enabling this feature would incur cost in terms of slight increase in index
size. Refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2306">OAK-2306</a> for more details.</p></section><section>
<h5><a name="Include_and_Exclude_paths_from_indexing"></a><a name="include-exclude"></a> Include and Exclude paths from indexing</h5>
<p><code>@since Oak 1.0.14, 1.2.3</code></p>
<p>Sometimes, only nodes under certain paths should be indexed (<code>includedPaths</code>).</p>
<p>If <code>includedPaths</code> is used, then <code>queryPaths</code> should be set to the same value(s).
This is because <code>excludedPaths</code> and <code>includedPaths</code> <i>don't</i>
affect the index selection logic for a query.
Path restrictions of queries are only checked against <code>queryPaths</code>.</p>
<p>The follow index definition causes nodes under <code>/content</code> and <code>/home</code> to be indexed:</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/abc
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - includedPaths = [&quot;/content&quot;, &quot;/home&quot;]
  - queryPaths = [&quot;/content&quot;, &quot;/home&quot;]
</code></pre></div>
<p>Sometimes, certain path should be excluded (<code>excludedPaths</code>),
e.g. transient system data.
If the application stores logs under <code>/var/log</code>, and this data is
not supposed to be indexed, then it can be excluded, by setting
<code>excludedPaths</code> to <code>[&quot;/var/log&quot;]</code>.
However, it is typically better to set <code>includedPaths</code> and <code>queryPaths</code>.</p>
<p><a name="query-paths"></a>
<b>queryPaths</b></p>
<p>If you need to ensure that a given index only gets used for query with specific
path restrictions then you need to specify those paths in <code>queryPaths</code>.</p>
<p>In most cases, if <code>queryPaths</code> is used, then <code>includedPaths</code> should be set to the same
value, to reduce the index size.</p>
<p>For example if <code>includedPaths</code> and <code>queryPaths</code> are set to <code>[&quot;/content&quot;, &quot;/home&quot;]</code>.
The index would be used for queries below <code>/content</code> as well as for queries below
<code>/home</code>. But it won't be used for queries without path restriction, or for queries below
<code>/tmp</code>.</p>
<p><b>Usage</b></p>
<p>Key points to consider while using <code>includedPaths</code>, <code>queryPaths</code>, and <code>excludedPaths</code>,</p>
<ol style="list-style-type: decimal">

<li>

<p><code>includedPaths</code> and <code>queryPaths</code> should typically be set to the same value(s).
Also, the query should use a matching path restriction.
That way, the index size can be reduced, and there are no surprises
that queries don't show data that is stored in the repository.</p>
</li>
<li>

<p>Only data should be indexes that is needed.
This shrinks the index size, and speeds up indexing.</p>
</li>
<li>

<p>Use <code>includedPaths</code>, <code>excludedPaths</code>, and <code>queryPaths</code> with caution.
If the wrong paths are excluded, then some nodes might not show up in query results
that should.</p>
</li>
<li>

<p>Sub-root index definitions (e.g. <code>/test/oak:index/index-def-node</code>) -
<code>excludedPaths</code> and <code>includedPaths</code> need to be relative to the path
that index is defined for. If the condition is supposed to be put for
<code>/test/a</code> where the index definition is at <code>/test/oak:index/index-def-node</code>
then <code>/a</code> needs to be put as value of <code>excludedPaths</code>
or <code>includedPaths</code>.
On the other hand, <code>queryPaths</code> remains to be an absolute path.
So, for the example above, <code>queryPaths</code> would get the value <code>/test/a</code>.</p>
</li>
</ol>
<p>See to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2599">OAK-2599</a> for more details.</p></section></section><section>
<h4><a name="Aggregation"></a><a name="aggregation"></a>Aggregation</h4>
<p>Sometimes it is useful to include the contents of descendant nodes into a single
node to easier search on content that is scattered across multiple nodes.</p>
<p>Oak allows you to define index aggregates based on relative path patterns and
primary node types. Changes to aggregated items cause the main item to be
reindexed, even if it was not modified.</p>
<p><b>Please note that aggregation does not support nodeType inheritance. To support aggregation on child nodeTypes, they need to be explicitly defined as a separate aggregation configuration in the index definition.</b></p>
<p>Aggregation configuration is defined under the <code>aggregates</code> node under index
configuration. The following example creates an index aggregate on nt:file that
includes the content of the jcr:content node:</p>

<div class="source"><pre class="prettyprint"><code>fulltextIndex
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + aggregates
    + nt:file
      + include0
        - path = &quot;jcr:content&quot;
</code></pre></div>
<p>By default, all properties whose type matches <code>includePropertyTypes</code> and are
part of child nodes as per the aggregation pattern are included for indexing.
For excluding certain properties define a property definition with relative
path and set <code>excludeFromAggregation</code> to <code>true</code>. Such properties would then be
excluded from fulltext index</p>
<p>For a given nodeType multiple includes can be defined. Below is the aggregate
definition structure for any specific include rule</p>

<div class="source"><pre class="prettyprint"><code>aggregateNodeInclude (nt:unstructured)
  - path (string) mandatory
  - primaryType (string)
  - relativeNode (boolean) = false
</code></pre></div>
<p>Following are the details about the above mentioned config options which can be
defined as part of aggregation include. (Refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2268">OAK-2268</a> for
implementation details)</p>
<dl>

<dt>path</dt>
<dd>Path pattern to include. Example
<ul>

<li><code>jcr:content</code> - Name explicitly specified</li>
<li><code>*</code> - Any child node at depth 1</li>
<li><code>*/*</code> - Any child node at depth 2</li>
</ul>
</dd>
<dt>primaryType</dt>
<dd>Restrict the included nodes to a certain type. The restriction would be
applied on the last node in given path

<div class="source"><pre class="prettyprint"><code>  + aggregates
    + nt:file
      + include0
        - path = &quot;jcr:content&quot;
        - primaryType = &quot;nt:resource&quot;
</code></pre></div></dd>
<dt>relativeNode</dt>
<dd>Boolean property indicates that query can be performed against specific node
For example for following content

<div class="source"><pre class="prettyprint"><code>  + space.txt (app:Asset)
    + renditions (nt:folder)
      + original (nt:file)
        + jcr:content (nt:resource)
          - jcr:data
</code></pre></div>
<p>And a query like</p>

<div class="source"><pre class="prettyprint"><code>  select * from [app:Asset] where contains([renditions/original/*], &quot;pluto&quot;)
</code></pre></div>
<p>Following index configuration would be required</p>

<div class="source"><pre class="prettyprint"><code>  fulltextIndex
    - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
    - compatVersion = 2
    - type = &quot;lucene&quot;
    - async = &quot;async&quot;
    + aggregates
      + nt:file
        + include0
          - path = &quot;jcr:content&quot;
      + app:Asset
        + include0
          - path = &quot;renditions/original&quot;
          - relativeNode = true
    + indexRules
      - jcr:primaryType = &quot;nt:unstructured&quot;
      + app:Asset
</code></pre></div></dd>
</dl>
<p><b>Aggregation and Recursion</b></p>
<p>While performing aggregation the aggregation rules are again applied on node
being aggregated. For example while aggregating for <i>app:Asset</i> above when
<i>renditions/original/*</i> is being aggregated then aggregation rule would again
be applied. In this case as  <i>renditions/original</i> is <i>nt:file</i> then aggregation
rule applicable for <i>nt:file</i> would be applied. Such a logic might result in
recursion. (See <a class="externalLink" href="https://issues.apache.org/jira/browse/JCR-2989?focusedCommentId=13051101">JCR-2989</a> for details).</p>
<p>For such case <code>reaggregateLimit</code> is set on aggregate definition node and
defaults to 5</p>

<div class="source"><pre class="prettyprint"><code>  + aggregates
    + app:Asset
      - reaggregateLimit (long) = 5
      + include0
        - path = &quot;renditions/original&quot;
        - relativeNode = true
</code></pre></div></section><section>
<h4><a name="Analyzers"></a><a name="analyzers"></a>Analyzers</h4>
<p>If no analyzer is specified, then <code>OakAnalyzer</code> is used, which uses the
Apache Lucene <code>StandardTokenizer</code>, the <code>LowerCaseFilter</code>,
and the <code>WordDelimiterFilter</code> with the following options:
<code>GENERATE_WORD_PARTS</code>, <code>STEM_ENGLISH_POSSESSIVE</code>, and <code>GENERATE_NUMBER_PARTS</code>.</p>
<p><code>@since Oak 1.5.5, 1.4.7, 1.2.19</code>
Unless custom analyzer is explicitly configured (as documented below), the built-in analyzer
can be configured to include the original term as well (<code>PRESERVE_ORIGINAL</code>). This is
controlled by setting boolean property <code>indexOriginalTerm</code> on the <code>analyzers</code> node:</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  + analyzers
    - indexOriginalTerm = true
</code></pre></div>
<p>(See <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-4516">OAK-4516</a> for details)</p>
<p><code>@since Oak 1.2.0</code></p>
<p>Analyzers can be configured as part of index definition via <code>analyzers</code> node.
The default analyzer can be configured via <code>analyzers/default</code> node</p>

<div class="source"><pre class="prettyprint"><code>    + sampleIndex
      - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
      + analyzers
        + default
          ...
</code></pre></div><section>
<h5><a name="Specify_analyzer_class_directly"></a><a name="analyzer-classes"></a>Specify analyzer class directly</h5>
<p>If any of the out of the box analyzer is to be used then it can configured directly</p>

<div class="source"><pre class="prettyprint"><code>    + analyzers
      + default
        - class = &quot;org.apache.lucene.analysis.standard.StandardAnalyzer&quot;
        - luceneMatchVersion = &quot;LUCENE_47&quot; (optional)
</code></pre></div>
<p>To confirm to specific version specify it via <code>luceneMatchVersion</code> otherwise Oak
would use a default version depending on version of Lucene it is shipped with.</p>
<p>One can also provide a stopword file via <code>stopwords</code> <code>nt:file</code> node under
the analyzer node</p>

<div class="source"><pre class="prettyprint"><code>    + analyzers
      + default
        - class = &quot;org.apache.lucene.analysis.standard.StandardAnalyzer&quot;
        - luceneMatchVersion = &quot;LUCENE_47&quot; (optional)
        + stopwords (nt:file)
</code></pre></div></section><section>
<h5><a name="Create_analyzer_via_composition"></a><a name="analyzer-composition"></a>Create analyzer via composition</h5>
<p>Analyzers can also be composed based on <code>Tokenizers</code>, <code>TokenFilters</code> and
<code>CharFilters</code>. This is similar to the support provided in Solr where you can
<a class="externalLink" href="https://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#Specifying_an_Analyzer_in_the_schema">configure analyzers in xml</a>.
In this case, the analyzer <code>class</code> property needs to be removed.
The <code>tokenizer</code> needs to be specified,
all the other components (e.g. <code>charFilters</code>, <code>Synonym</code>) are optional.</p>

<div class="source"><pre class="prettyprint"><code>    + analyzers
      + default
        + charFilters (nt:unstructured) // the filters needs to be ordered
          + HTMLStrip
          + Mapping
        + tokenizer
          - name = &quot;Standard&quot;
        + filters (nt:unstructured) // the filters needs to be ordered
          + LowerCase
          + Stop
            - words = &quot;stop1.txt, stop2.txt&quot;
            + stop1.txt (nt:file)
            + stop2.txt (nt:file)
          + PorterStem
          + Synonym
            - synonyms = &quot;synonym.txt&quot;
            + synonym.txt (nt:file)
</code></pre></div></section></section><section>
<h4><a name="Examples"></a>Examples</h4>
<p>To convert umlauts using ASCII folding, use the following.
(ASCII folding converts characters to Basic Latin where possible.
This includes umlauts, characters with accents, and so on.)</p>

<div class="source"><pre class="prettyprint"><code>    + analyzers
      + default
        + tokenizer
          - name = &quot;Standard&quot;
        + filters (nt:unstructured) // the filters needs to be ordered
          + ASCIIFolding
</code></pre></div>
<p>For stemming support, use:</p>

<div class="source"><pre class="prettyprint"><code>1. Use an analyzer which has stemming included by default e.g. EnglishAnalyzer which has PorterStemFilter.
    + analyzers
      + default
        - class = &quot;org.apache.lucene.analysis.en.EnglishAnalyzer&quot;

2. Use stemming as part of analyzer composition (using org.apache.lucene.analysis.hunspell.HunspellStemFilterFactory)
    + analyzers
      + default
        + tokenizer
          - name = &quot;Standard&quot;
        + filters (nt:unstructured) // the filters needs to be ordered
          + LowerCase
          + HunspellStem
            - dictionary = &quot;en_gb.dic&quot;
            - affix = &quot;en_gb.aff&quot;
            + en_gb.aff (nt:file)
            + en_gb.dic (nt:file)

</code></pre></div>
<p>Points to note</p>
<ol style="list-style-type: decimal">

<li>Name of filters, charFilters and tokenizer are formed by removing the
factory suffixes. So
<ul>

<li>org.apache.lucene.analysis.standard.StandardTokenizerFactory -&gt; <code>Standard</code></li>
<li>org.apache.lucene.analysis.charfilter.MappingCharFilterFactory -&gt; <code>Mapping</code></li>
<li>org.apache.lucene.analysis.core.StopFilterFactory -&gt; <code>Stop</code></li>
</ul>
</li>
<li>Any config parameter required for the factory is specified as property of
that node
<ul>

<li>If the factory requires to load a file e.g. stop words from some file then
file content can be provided via creating child <code>nt:file</code> node of the
filename</li>
<li>The property value MUST be of type <code>String</code>. No other JCR type should be used
for them like array or integer etc</li>
</ul>
</li>
<li>The analyzer-chain processes text from nodes as well text passed in query. So,
do take care that any mapping configuration (e.g. synonym mappings) factor in
the chain of analyzers.
E.g a common mistake for synonym mapping would be to have <code>domain =&gt; Range</code> while
there's a lower case filter configured as well (see the example above). For such
a setup an indexed value <code>domain</code> would actually get indexed as <code>Range</code> (mapped
value doesn't have lower case filter below it) but a query for <code>Range</code> would actually
query for <code>range</code> (due to lower case filter) and won't give the result (as might be
expected). An easy work-around for this example could be to have lower case mappings
i.e. just use <code>domain =&gt; range</code>.</li>
<li>Precedence: Specifying analyzer class directly has precedence over analyzer configuration
by composition. If you want to configure analyzers by composition then analyzer class
MUST NOT be specified. In-build analyzer has least precedence and comes into play only
if no custom analyzer has been configured. Similarly, setting <code>indexOriginalTerm</code> on
analyzers node to modify behavior of in-built analyzer also works only when no custom
analyzer has been configured.</li>
<li>To determine list of supported factories have a look at Lucene javadocs for
<ul>

<li><a class="externalLink" href="https://lucene.apache.org/core/4_7_1/analyzers-common/org/apache/lucene/analysis/util/TokenizerFactory.html">TokenizerFactory</a></li>
<li><a class="externalLink" href="https://lucene.apache.org/core/4_7_1/analyzers-common/org/apache/lucene/analysis/util/CharFilterFactory.html">CharFilterFactory</a></li>
<li><a class="externalLink" href="https://lucene.apache.org/core/4_7_1/analyzers-common/org/apache/lucene/analysis/util/TokenFilterFactory.html">FilterFactory</a></li>
</ul>
</li>
<li>Oak support for composing analyzer is based on Lucene. So some helpful docs around this
<ul>

<li><a class="externalLink" href="https://cwiki.apache.org/confluence/display/solr/Understanding+Analyzers%2C+Tokenizers%2C+and+Filters">https://cwiki.apache.org/confluence/display/solr/Understanding+Analyzers%2C+Tokenizers%2C+and+Filters</a></li>
<li><a class="externalLink" href="https://cwiki.apache.org/confluence/display/solr/CharFilterFactories">https://cwiki.apache.org/confluence/display/solr/CharFilterFactories</a></li>
<li><a class="externalLink" href="https://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#Specifying_an_Analyzer_in_the_schema">https://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#Specifying_an_Analyzer_in_the_schema</a></li>
</ul>
</li>
<li>When defining synonyms:
<ul>

<li>in the synonym file, lines like <i>plane, airplane, aircraft</i> refer to tokens that are mutual synoyms whereas lines
like <i>plane =&gt; airplane</i> refer to <i>one way</i> synonyms, so that plane will be expanded to airplane but not vice versa</li>
<li>continuing with the point above, since oak would use the same
analyzer for indexing as well as querying, using one-way synonyms in
any practical way is not supported at the moment.</li>
<li>special characters have to be escaped</li>
<li>multi word synonyms need particular attention (see <a class="externalLink" href="https://lucidworks.com/post/solution-for-multi-term-synonyms-in-lucenesolr-using-the-auto-phrasing-tokenfilter/">https://lucidworks.com/post/solution-for-multi-term-synonyms-in-lucenesolr-using-the-auto-phrasing-tokenfilter/</a>)</li>
</ul>
</li>
</ol>
<p>Note that currently only one analyzer can be configured per index. Its not possible to specify separate
analyzer for query and index time currently.</p></section><section>
<h4><a name="Codec"></a><a name="codec"></a>Codec</h4>
<p>Name of <a class="externalLink" href="https://lucene.apache.org/core/4_7_1/core/org/apache/lucene/codecs/Codec.html">Lucene Codec</a> to use. By default, if the index involves
fulltext indexing then Oak Lucene uses <code>OakCodec</code> which disables compression.
Due to this the index size may grow large. To enable compression you can set
the codec to <code>Lucene46</code></p>

<div class="source"><pre class="prettyprint"><code>/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - codec = &quot;Lucene46&quot;
</code></pre></div>
<p>Refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2853">OAK-2853</a> for details. Enabling the <code>Lucene46</code> codec
would lead to smaller and compact indexes.</p></section><section>
<h4><a name="Boost_and_Search_Relevancy"></a><a name="boost"></a>Boost and Search Relevancy</h4>
<p><code>@since Oak 1.2.5</code></p>
<p>When fulltext indexing is enabled then internally Oak would create a fulltext
field which consists of text extracted from various other fields i.e. fields
for which <code>nodeScopeIndex</code> is <code>true</code>. This allows search like
<code>/jcr:root/content//*[jcr:contains(., 'foo')]</code> to perform search across any indexable field
containing foo (See <a class="externalLink" href="https://s.apache.org/jcr-1.0-spec/6.6.5.2_jcr_contains_Function.html">contains function</a> for details)</p>
<p>In certain cases its desirable that those nodes where the searched term is present
in a specific property are ranked higher (come earlier in search result) compared
to those node where the searched term is found in some other property.</p>
<p>In such cases it should be possible to boost specific text contributed by
individual property. Meaning that if a title field is boosted more than description,
then search result would those node coming earlier where searched term is found
in title field</p>
<p>For that to work ensure that for each such property (which need to be preferred)
both <code>nodeScopeIndex</code> and <code>analyzed</code> are set to true. In addition, you can specify
<code>boost</code> property so give higher weightage to values found in specific property</p>
<p>Note that even without setting explicit <code>boost</code> and just setting <code>nodeScopeIndex</code>
and <code>analyzed</code> to true would improve the search result due to the way
<a class="externalLink" href="https://wiki.apache.org/lucene-java/LuceneFAQ#How_do_I_make_sure_that_a_match_in_a_document_title_has_greater_weight_than_a_match_in_a_document_body.3F">Lucene does scoring</a>. Internally Oak would create separate Lucene
fields for those jcr properties and would perform a search across all such fields.
For more details refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-3367">OAK-3367</a></p>

<div class="source"><pre class="prettyprint"><code>  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + description
          - nodeScopeIndex = true
          - analyzed = true
          - name = &quot;jcr:content/metadata/jcr:description&quot;
        + title
          - analyzed = true
          - nodeScopeIndex = true
          - name = &quot;jcr:content/metadata/jcr:title&quot;
          - boost = 2.0
</code></pre></div>
<p>With above index config a search like</p>

<div class="source"><pre class="prettyprint"><code>SELECT * FROM [app:Asset]
WHERE CONTAINS(., 'Batman')
</code></pre></div>
<p>Would have those node (of type app:Asset) come first where <i>Batman</i> is found in
<i>jcr:title</i>. While those nodes where search text is found in other field
like aggregated content would come later</p></section><section>
<h4><a name="Effective_Index_Definition"></a><a name="stored-index-definition"></a>Effective Index Definition</h4>
<p><code>@since Oak 1.6</code></p>
<p>Prior to Oak 1.6 index definition as defined in content was directly used for query
execution and indexing. It was possible that index definition is modified in incompatible
way and that would start affecting the query execution leading to inconsistent result.</p>
<p>Since Oak 1.6 the index definitions are cloned upon reindexing and stored in a hidden structure.
For further incremental indexing and for query plan calculation the stored index definition is used.
So any changes done post reindex to index definition would not be applicable until a reindex is done.</p>
<p>There would be some cases where changes in index definition does not require a reindex. For e.g. if a new property
is being introduced in content model and no prior content exist with such a property then it's safe to index such
a property without doing a reindex. For such cases user must follow below steps</p>
<ol style="list-style-type: decimal">

<li>Make the required changes</li>
<li>Set <code>refresh</code> property to <code>true</code> in index definition node</li>
<li>Save the changes</li>
</ol>
<p>On next async indexing cycle this flag would be picked up and stored index definition would be refreshed.
<i>Post this the flag would be automatically removed and a log message would be logged</i>. You would also see a
log message like below</p>

<div class="source"><pre class="prettyprint"><code>LuceneIndexEditorContext - Refreshed the index definition for [/oak:index/fooLuceneIndex]
</code></pre></div>
<p>To simplify troubleshooting the stored index definition can be accessed from <code>LuceneIndexMBean</code> via
<code>getStoredIndexDefinition</code> operation. It would dump the string representation of stored NodeState</p>
<p><img src="lucene-index-mbean-dump-index.png" alt="Dump Stored Index Definition" /></p>
<p>This feature can be disabled by setting OSGi property <code>disableStoredIndexDefinition</code> for <code>LuceneIndexProviderService</code>
to true. Once disable any change in index definition would start effecting the query plans</p>
<p>Refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-4400">OAK-4400</a> for more details.</p></section><section>
<h4><a name="Generating_Index_Definition"></a><a name="generate-index-definition"></a> Generating Index Definition</h4>
<p>To simplify generating index definition suitable for evaluating certain set of queries you can make use of
<a class="externalLink" href="http://oakutils.appspot.com/generate/index">http://oakutils.appspot.com/generate/index</a>. Here you can provide a set of queries and then it would generate the
suitable index definitions for those queries.</p>
<p>Note that you would still need to tweak the definition for aggregation, path include exclude etc as that data cannot
be inferred from the query</p></section></section><section>
<h3><a name="Near_Real_Time_Indexing"></a><a name="nrt-indexing"></a> Near Real Time Indexing</h3>
<p><code>@since Oak 1.6</code></p>
<p>Refer to <a href="indexing.html#nrt-indexing">Near realtime indexing</a> for more details</p></section><section>
<h3><a name="LuceneIndexProvider_Configuration"></a><a name="osgi-config"></a>LuceneIndexProvider Configuration</h3>
<p>Some of the runtime aspects of the Oak Lucene support can be configured via OSGi
configuration. The configuration needs to be done for PID <code>org.apache .jackrabbit.oak.plugins.index.lucene.LuceneIndexProviderService</code></p>
<p><img src="lucene-osgi-config.png" alt="OSGi Configuration" /></p>
<dl>

<dt>enableCopyOnReadSupport</dt>
<dd>Enable copying of Lucene index to local file system to improve query
performance. See <a href="#copy-on-read">Copy Indexes On Read</a></dd>
<dt>enableCopyOnWriteSupport</dt>
<dd>Enable copying of Lucene index to local file system to improve indexing
performance. See <a href="#copy-on-write">Copy Indexes On Write</a></dd>
<dt>localIndexDir</dt>
<dd>Directory to be used for when copy index files to local file system. To be
specified when <code>enableCopyOnReadSupport</code> is enabled</dd>
<dt>prefetchIndexFiles</dt>
<dd>Prefetch the index files when CopyOnRead is enabled. When enabled all new Lucene
index files would be copied locally before the index is made available to
QueryEngine (1.0.17,1.2.3)</dd>
<dt>debug</dt>
<dd>Boolean value. Defaults to <code>false</code></dd>
<dd>If enabled then Lucene logging would be integrated with Slf4j</dd>
</dl></section><section>
<h3><a name="Tika_Config"></a><a name="tika-config"></a>Tika Config</h3>
<p><code>@since Oak 1.0.12, 1.2.3</code></p>
<p>Oak Lucene uses <a class="externalLink" href="http://tika.apache.org/">Apache Tika</a> to extract the text from binary content</p>

<div class="source"><pre class="prettyprint"><code>+ tika
    - maxExtractLength (long) = -10
    + config.xml  (nt:file)
      + jcr:content
        - jcr:data = //config xml binary content
</code></pre></div>
<p>Oak uses a <a class="externalLink" href="https://github.com/apache/jackrabbit-oak/blob/trunk/oak-lucene/src/main/resources/org/apache/jackrabbit/oak/plugins/index/lucene/tika-config.xml">default config</a>. To use a custom config specify
the config file via <code>tika/config.xml</code> node in index config.</p>
<dl>

<dt><a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2470">maxExtractLength</a></dt>
<dd>Limits the number of characters that are extracted by the Tika parse. A negative
value indicates a multiple of <code>maxFieldLength</code> and a positive value is used as is
<ul>

<li>maxExtractLength = -10, maxFieldLength = 10000 -&gt; Actual value = 100000</li>
<li>maxExtractLength = 1000 -&gt; Actual value = 1000</li>
</ul>
</dd>
</dl><section>
<h4><a name="Mime_type_usage"></a><a name="mime-type-usage"></a>Mime type usage</h4>
<p>A binary is only indexed if there is an associated property <code>jcr:mimeType</code> defined
and that is supported by Tika. By default, indexer uses <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2895">TypeDetector</a>
instead of default <code>DefaultDetector</code> which relies on the <code>jcr:mimeType</code> to pick up the
right parser.</p></section><section>
<h4><a name="Mime_type_mapping"></a><a name="mime-type-mapping"></a>Mime type mapping</h4>
<p><code>@since Oak 1.7.7</code></p>
<p>In certain circumstances, it may be desired to pass a value other than the <code>jcr:mimeType</code> property
into the Tika parser. For example, this would be necessary if a binary has an application-specific
mime type, but is parsable by the standard Tika parser for some generic type. To support these cases,
create a node structure under the <code>tika/mimeTypes</code> node following the mime type structure, e.g.</p>

<div class="source"><pre class="prettyprint"><code>+ tika
    + mimeTypes (nt:unstructured)
      + application (nt:unstructured)
        + vnd.mycompany-document (nt:unstructured)
          - mappedType = application/pdf
</code></pre></div>
<p>When this index is indexing a binary of type <code>application/vnd.mycompany-document</code> it will force Tika
to treat it as a binary of type <code>application/pdf</code>.</p></section></section><section>
<h3><a name="Non_Root_Index_Definitions"></a><a name="non-root-index"></a>Non Root Index Definitions</h3>
<p>Lucene index definition can be defined at any location in repository and need
not always be defined at root. For example if your query involves path
restrictions like</p>

<div class="source"><pre class="prettyprint"><code>select * from [app:Asset] as a where ISDESCENDANTNODE(a, '/content/companya') and [format] = 'image'
</code></pre></div>
<p>Then you can create the required index definition say <code>assetIndex</code> at
<code>/content/companya/oak:index/assetIndex</code>. In such a case that index would
contain data for the subtree under <code>/content/companya</code></p></section><section>
<h3><a name="Function-Based_Indexing"></a><a name="function-based-indexing"></a>Function-Based Indexing</h3>
<p><code>@since Oak 1.5.11, 1.6.0, 1.42.0</code></p>
<p>Function-based indexes can for example allow to search (or order by) the lower case version of a property.
For more details see <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-3574">OAK-3574</a> and <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-9625">OAK-9625</a>.</p>
<p>For example using the index definition</p>

<div class="source"><pre class="prettyprint"><code>uppercaseLastName
  - function = &quot;fn:upper-case(@lastName)&quot;
  - propertyIndex = true
  - ordered = true
</code></pre></div>
<p>This allows to search for, and order by, the lower case version of the property &#x201c;lastName&#x201d;. Example functions:</p>
<ul>

<li>fn:upper-case(@data)</li>
<li>fn:lower-case(test/@data)</li>
<li>fn:lower-case(fn:name())</li>
<li>fn:lower-case(fn:local-name())</li>
<li>fn:string-length(test/@data)</li>
<li>first([alias])</li>
<li>upper([data])</li>
<li>lower([test/data])</li>
<li>lower(name())</li>
<li>lower(localname())</li>
<li>length([test/data])</li>
<li>length(name())</li>
<li>name()</li>
<li>path()</li>
</ul>
<p>Indexing multi-valued properties is supported.
Relative properties are supported (except for &#x201c;..&#x201d; and &#x201c;.&#x201d;).
Range conditions are supported (&#x2018;&gt;&#x2019;, &#x2018;&gt;=&#x2019;, &#x2018;&lt;=&#x2019;, &#x2018;&lt;&#x2019;).</p>
<p>The functions path(), first(), and name() require Oak version 1.42.0 or newer.</p></section><section>
<h3><a name="Dynamic_Boost"></a><a name="dynamic-boost"></a>Dynamic Boost</h3>
<p><code>@since Oak 1.28.0</code></p>
<p>To enable the feature, add a property to be indexed, e.g.:</p>

<div class="source"><pre class="prettyprint"><code>dynamicBoost
 - dynamicBoost = true (Boolean)
 - propertyIndex = true
 - name = jcr:content/metadata/predictedTags/.* (String)
 - isRegexp = true (Boolean)
</code></pre></div>
<p>That way, if a node <code>jcr:content/metadata/predictedTags</code> is added (for the indexed node type),
then dynamic boost is used. It will read the child nodes of that node
(<code>jcr:content/metadata/predictedTags</code>) and for each node it will read:</p>
<ul>

<li>name (String)</li>
<li>confidence (Double)</li>
</ul>
<p>It will then add a field, for each token of the &#x201c;name&#x201d; property,
with boost set to the confidence.
This is a replacement for the <code>IndexFieldProvider</code>.
See also <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-8971">OAK-8971</a>.</p></section><section>
<h3><a name="Native_Query_and_Index_Selection"></a><a name="native-query"></a>Native Query and Index Selection</h3>
<p><code>@deprecated Oak 1.46</code></p>
<p>Oak query engine supports native queries like</p>

<div class="source"><pre class="prettyprint"><code>/jcr:root/content//*[rep:native('lucene', 'name:(Hello OR World)')]
</code></pre></div>
<p>If multiple Lucene based indexes are enabled on the system and you need to
make use of specific Lucene index like <code>/oak:index/assetIndex</code> then you can
specify the index name via <code>functionName</code> attribute on index definition.</p>
<p>For example for assetIndex definition like</p>

<div class="source"><pre class="prettyprint"><code>luceneAssetIndex
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - type = &quot;lucene&quot;
  ...
  - functionName = &quot;lucene-assetIndex&quot;
</code></pre></div>
<p>Executing following query would ensure that Lucene index from <code>assetIndex</code>
should be used</p>

<div class="source"><pre class="prettyprint"><code>/jcr:root/content//*[rep:native('lucene-assetIndex', 'name:(Hello OR World)')]
</code></pre></div></section><section>
<h3><a name="Persisting_indexes_to_FileSystem"></a><a name="persisting-indexes"></a>Persisting indexes to FileSystem</h3>
<p>By default, Lucene indexes are stored in the <code>NodeStore</code>. If required they can
be stored on the file system directly</p>

<div class="source"><pre class="prettyprint"><code>- jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
- type = &quot;lucene&quot;
...
- persistence = &quot;file&quot;
- path = &quot;/path/to/store/index&quot;
</code></pre></div>
<p>To store the Lucene index in the file system, in the Lucene index definition
node, set the property <code>persistence</code> to <code>file</code>, and set the property <code>path</code>
to the directory where the index should be stored. Then start reindexing by
setting <code>reindex</code> to <code>true</code>.</p>
<p>Note that this setup would only for those non cluster <code>NodeStore</code>. If the
backend <code>NodeStore</code> supports clustering then index data would not be
accessible on other cluster nodes</p></section><section>
<h3><a name="CopyOnRead"></a><a name="copy-on-read"></a>CopyOnRead</h3>
<p>Lucene indexes are stored in <code>NodeStore</code>. Oak Lucene provides a custom directory
implementation which enables Lucene to load index from <code>NodeStore</code>. This
might cause performance degradation if the <code>NodeStore</code> storage is remote. For
such case Oak Lucene provide a <code>CopyOnReadDirectory</code> which copies the index
content to a local directory and enables Lucene to make use of local
directory based indexes while performing queries.</p>
<p>At runtime various details related to copy on read features are exposed via
<code>CopyOnReadStats</code> MBean. Indexes at JCR path e.g. <code>/oak:index/assetIndex</code>
would be copied to <code>&lt;index dir&gt;/&lt;hash of jcr path&gt;</code>. To determine mapping
between local index directory and JCR path refer to the MBean details</p>
<p><img src="lucene-index-copier-mbean.png" alt="CopyOnReadStats" /></p>
<p>For more details refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-1724">OAK-1724</a>. This feature can be enabled via
<a href="#osgi-config">Lucene Index provider service configuration</a></p>
<p><i>With Oak 1.0.13 this feature is now enabled by default.</i></p></section><section>
<h3><a name="CopyOnWrite"></a><a name="copy-on-write"></a>CopyOnWrite</h3>
<p><code>@since Oak 1.0.15, 1.2.3</code></p>
<p>Similar to <i>CopyOnRead</i> feature Oak Lucene also supports <i>CopyOnWrite</i> to enable
faster indexing by first buffering the writes to local filesystem and transferring
them to remote storage asynchronously as the indexing proceeds. This should
provide better performance and hence faster indexing times.</p>
<p><b>indexPath</b></p>
<p><i>Not required from Oak 1.6 , 1.4.7+</i></p>
<p>To speed up the indexing with CopyOnWrite you would also need to set <code>indexPath</code>
in index definition to the path of index in the repository. For e.g. if your
index is defined at <code>/oak:index/lucene</code> then value of <code>indexPath</code> should be set
to <code>/oak:index/lucene</code>. This would enable the indexer to perform any read
during the indexing process locally and thus avoid costly read from remote.</p>
<p>For more details refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2247">OAK-2247</a>. This feature can be enabled via
<a href="#osgi-config">Lucene Index provider service configuration</a></p></section><section>
<h3><a name="Lucene_Index_MBeans"></a><a name="mbeans"></a>Lucene Index MBeans</h3>
<p>Oak Lucene registers a JMX bean <code>LuceneIndex</code> which provide details about the
index content e.g. size of index, number of documents present in index etc</p>
<p><img src="lucene-index-mbean.png" alt="Lucene Index MBean" /></p>
<p>This MBean supports retrieving index fields and terms using the <code>getFieldTermsInfo(java.lang.String indexPath, java.lang.String field, int max)</code>
and the <code>getFieldTermsInfo(java.lang.String indexPath, java.lang.String field, java.lang.String fieldType, int max)</code> methods.</p>
<p>The first method always assumes the return type is a String, the second method allows you to specify the return type as either:</p>
<ul>

<li>String (value: String, java.lang.String)</li>
<li>Long (value: long, java.lang.Long)</li>
<li>Integer (value: int, java.lang.Integer)</li>
</ul>
<p>For example:</p>
<p><img src="lucene-index-mbean-getfieldtermsinfo.png" alt="Lucene Index MBean - getFieldTermsInfo" /></p></section><section>
<h3><a name="Active_Index_Files_Collection"></a><a name="active-blob-collection"></a>Active Index Files Collection</h3>
<p><code>@since Oak 1.7.12</code></p>
<p>Lucene indexing for moderately active repository creates a lot of deleted files.
This creates excessive load for usual mark-sweep garbage collection. Since, blobs
related to indexed data are explicitly made unique, it's safe to delete them as
soon as index node referring that blob is deleted.</p>
<p>Such active deletion of index blobs was implemented in <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2808">OAK-2808</a>. The
feature periodically deletes blobs which are deleted from the index. This &#x2018;period&#x2019;
can be controlled by <code>deletedBlobsCollectionInterval</code> property in
<a href="#osgi-config">Lucene Index provider service configuration</a>.</p>
<p>The feature would only delete blobs which have been deleted before a certain time.
The task to actually purge blobs from datastore is performed by jmx operation. Jmx bean
for the operation is <code>org.apache.jackrabbit.oak:name=Active lucene files collection,type=ActiveDeletedBlobCollector</code>
and the operation is <code>startActiveCollection()</code>.
To disable active deletion in a certain installation, set the system property <code>oak.active.deletion.disabled</code>.</p></section><section>
<h3><a name="Analyzing_created_Lucene_Index"></a><a name="luke"></a>Analyzing created Lucene Index</h3>
<p><a class="externalLink" href="https://code.google.com/p/luke/">Luke</a>  is a handy development and diagnostic tool, which accesses already
existing Lucene indexes and allows you to display index details. In Oak,
Lucene index files are not directly
accessible. To enable analyzing the index files via Luke follow below
mentioned steps</p>
<ol style="list-style-type: decimal">

<li>

<p>Download the Luke version which includes the matching Lucene jars used by
Oak. As of Oak 1.0.8 release the Lucene version used is 4.7.1. So download
the jar from <a class="externalLink" href="https://github.com/DmitryKey/luke/releases">here</a></p>

<div class="source"><pre class="prettyprint"><code> $wget https://github.com/DmitryKey/luke/releases/download/4.7.0/luke-with-deps.jar
</code></pre></div>
</li>
<li>

<p>Use the <a class="externalLink" href="https://github.com/apache/jackrabbit-oak/tree/trunk/oak-run#console">Oak Console</a> to dump the Lucene index files to a directory.
Use the <code>lc dump</code> command as follows:</p>

<div class="source"><pre class="prettyprint"><code> $ java -jar oak-run-*.jar console /path/to/oak/repository
 Apache Jackrabbit Oak 1.1-SNAPSHOT
 Jackrabbit Oak Shell (Apache Jackrabbit Oak 1.1-SNAPSHOT, JVM: 1.7.0_55)
 Type ':help' or ':h' for help.
 -------------------------------------------------------------------------
 /&gt; lc info /oak:index/lucene
 Index size : 74.1 MB
 Number of documents : 235708
 Number of deleted documents : 231
 /&gt; lc
 dump   info
 /&gt; lc dump /path/to/dump/index/lucene /oak:index/lucene
 Copying Lucene indexes to [/path/to/dump/index/lucene]
 Copied 74.1 MB in 1.209 s
 /&gt; lc dump /path/to/dump/index/slingAlias /oak:index/slingAlias
 Copying Lucene indexes to [/path/to/dump/index/lucene-index/slingAlias]
 Copied 8.5 MB in 218.7 ms
 /&gt;
</code></pre></div>
</li>
<li>

<p>Afterwards, open the index via Luke. Oak Lucene uses a <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-1737">custom
Codec</a>. So oak-lucene jar needs to be included in Luke classpath
for it to display the index details</p>

<div class="source"><pre class="prettyprint"><code> $ java -XX:MaxPermSize=512m -cp luke-with-deps.jar:oak-lucene-1.0.8.jar org.getopt.luke.Luke
</code></pre></div>
</li>
</ol>
<p>From the Luke UI shown you can access various details.</p></section><section>
<h3><a name="Pre-Extracting_Text_from_Binaries"></a><a name="text-extraction"></a>Pre-Extracting Text from Binaries</h3>
<p>Refer to <a href="pre-extract-text.html">pre-extraction via oak-run</a>.</p></section><section>
<h3><a name="Advanced_search_features"></a><a name="advanced-search-features"></a>Advanced search features</h3><section>
<h4><a name="Suggestions"></a><a name="suggestions"></a>Suggestions</h4>
<p><code>@since Oak 1.1.17, 1.0.15</code></p>
<p>In order to use Lucene index to perform search suggestions, the index definition
node (the one of type <code>oak:QueryIndexDefinition</code>) needs to have the <code>compatVersion</code>
set to <code>2</code>, then one or more property nodes, depending on use case, need to have
the property <code>useInSuggest</code> set to <code>true</code>, such setting controls from which
properties terms to be used for suggestions will be taken.</p>
<p>Once the above configuration has been done, by default, the Lucene suggester is
updated every 10 minutes but that can be changed by setting the property
<code>suggestUpdateFrequencyMinutes</code> in <code>suggestion</code> node under the index definition
node to a different value.
<i>Note that up till Oak 1.3.14/1.2.14, <code>suggestUpdateFrequencyMinutes</code> was to be setup at
index definition node itself. That is is still supported for backward compatibility,
but having a separate <code>suggestion</code> node is preferred.</i></p>
<p>Sample configuration for suggestions based on terms contained in <code>jcr:description</code>
property.</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/lucene-suggest
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + suggestion
    - suggestUpdateFrequencyMinutes = 20
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + jcr:description
          - propertyIndex = true
          - analyzed = true
          - useInSuggest = true
</code></pre></div>
<p><code>@since Oak 1.3.12, 1.2.14</code> the index Analyzer can be used to perform a have more fine grained suggestions, e.g. single words
(whereas default suggest configuration returns entire property values, see [OAK-3407]: <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-3407">https://issues.apache.org/jira/browse/OAK-3407</a>).
Analyzed suggestions can be enabled by setting &#x201c;suggestAnalyzed&#x201d; property to true, e.g.:</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/lucene-suggest
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + suggestion
    - suggestUpdateFrequencyMinutes = 20
    - suggestAnalyzed = true
</code></pre></div>
<p><i>Note that up till Oak 1.3.14/1.2.14, <code>suggestAnalyzed</code> was to be setup at index definition node itself. That is still
supported for backward compatibility, but having a separate <code>suggestion</code> node is preferred.</i></p>
<p>Setting up <code>useInSuggest=true</code> for a property definition having <code>name=:nodeName</code> would add node names to
suggestion dictionary (See <a href="#property-names">property name</a> for node name indexing)</p>
<p>Since, Oak 1.3.16/1.2.14, very little support exists for queries with <code>ISDESCENDANTNODE</code> constraint to subset suggestions
on a sub-tree.  It requires <code>evaluatePathRestrictions=true</code> on index definition. e.g.</p>

<div class="source"><pre class="prettyprint"><code>SELECT rep:suggest() FROM [nt:base] WHERE SUGGEST('test') AND ISDESCENDANTNODE('/a/b')
</code></pre></div>
<p>or</p>

<div class="source"><pre class="prettyprint"><code>/jcr:root/a/b//[rep:suggest('in 201')]/(rep:suggest())
</code></pre></div>
<p>Note, the subset is done by filtering top 10 suggestions. So, it's possible to get no suggestions for a subtree query,
if top 10 suggestions are not part of that subtree. For details look at <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-3994">OAK-3994</a> and related issues.</p></section><section>
<h4><a name="Spellchecking"></a><a name="spellchecking"></a>Spellchecking</h4>
<p><code>@since Oak 1.1.17, 1.0.13</code></p>
<p>In order to use Lucene index to perform spellchecking, the index definition node
(the one of type <code>oak:QueryIndexDefinition</code>) needs to have the <code>compatVersion</code>
set to <code>2</code>, then one or more property nodes, depending on use case, need to have
the property <code>useInSpellcheck</code> set to <code>true</code>, such setting controls from which
properties terms to be used for spellcheck corrections will be taken.</p>
<p>Sample configuration for spellchecking based on terms contained in <code>jcr:title</code>
property.</p>
<p>Since Oak 1.3.11/1.2.14, each suggestion would be returned per row.</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/lucene-spellcheck
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + jcr:title
          - propertyIndex = true
          - analyzed = true
          - useInSpellcheck = true
</code></pre></div>
<p>Since, Oak 1.3.16/1.2.14, very little support exists for queries with <code>ISDESCENDANTNODE</code> constraint to subset suggestions
on a sub-tree. It requires <code>evaluatePathRestrictions=true</code> on index definition. e.g.</p>

<div class="source"><pre class="prettyprint"><code>SELECT rep:suggest() FROM [nt:base] WHERE SUGGEST('test') AND ISDESCENDANTNODE('/a/b')
</code></pre></div>
<p>or</p>

<div class="source"><pre class="prettyprint"><code>/jcr:root/a/b//[rep:suggest('in 201')]/(rep:suggest())
</code></pre></div>
<p>Note, the subset is done by filtering top 10 spellchecks. So, it's possible to get no results for a subtree query,
if top 10 spellchecks are not part of that subtree. For details look at <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-3994">OAK-3994</a> and related issues.</p></section><section>
<h4><a name="Facets"></a><a name="facets"></a>Facets</h4>
<p><code>@since Oak 1.3.14</code></p>
<p>Lucene property indexes can also be used for retrieving facets, in order to do so the property <i>facets</i> must be set to
<i>true</i> on the property definition.</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/lucene-with-facets
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + tags
          - facets = true
          - propertyIndex = true
</code></pre></div>
<p>Specific facet related features for Lucene property index can be configured in a separate <i>facets</i> node below the
index definition.
<code>@since Oak 1.5.15</code> The no. of facets to be retrieved is configurable via the <i>topChildren</i> property, which defaults to 10.</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/lucene-with-more-facets
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + facets
    - topChildren = 100
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + tags
          - facets = true
          - propertyIndex = true
</code></pre></div>
<p>By default, ACL checks are always performed on facets by the Lucene property index.
This is secure (no information leakage is possible), but can be slow.
The <i>secure</i> configuration property allows to configure how facet counts are performed.
<code>@since Oak 1.6.16, 1.8.10, 1.9.13</code> <code>secure</code> property is a string with allowed values of <code>secure</code>, <code>statistical</code> and
<code>insecure</code> - <code>secure</code> being the default value. Before that <code>secure</code> was a boolean property and to maintain compatibility
<code>false</code> maps to <code>insecure</code> while <code>true</code> (default at the time) maps to <code>secure</code>.
The following configuration options are supported:</p>
<ul>

<li>

<p><code>secure</code> (the default) means all results of a query are checked for access permissions.
Facets and counts returned by index reflect what is accessible to the given user.
The query result therefore only reflects information the user has access rights for.
This can be slow, specially for large result set.</p>
</li>
<li>

<p><code>insecure</code> means the facet counts are reported as stored in the index, without performing access rights checks.
This setting may allow users to infer the existence of content to which they do not have access.
It is recommended to use this setting only if either the index is guaranteed to only contain data that is public
(e.g. a public subtree of the repository), or if the information is not sensitive.</p>
</li>
<li>

<p><code>statistical</code> means the data is sampled randomly (default <code>1000</code> configurable via
<code>sampleSize</code>), and ACL checks are performed on this sample.
Facet counts returned are proportional to the percentage of accessible samples that were checked for ACL.
Warning: this setting potentially leaks repository information the user that runs the query may not see.
It must only be used if either the index is guaranteed to only contain data that is public
(e.g. a public subtree of the repository), or if the leaked information is not sensitive.
Do note that the <a class="externalLink" href="https://onlinecourses.science.psu.edu/stat100/node/16/">beauty of sampling</a> is that a sample size of
<code>1000</code> has an error rate of 3% with 95% confidence, if ACLs are evenly distributed over the sampled data.
However, often ACLs are not evenly distributed. Also, a low rate of accessible documents
decreases chances to reach that average rate. To have a sense of
expectation of error rate, here's how errors looked like in different scenarios of test runs with sample size of 1000
with error averaged over 1000 random runs for each scenario.</p>
</li>
</ul>

<div class="source"><pre class="prettyprint"><code>|-----------------|-----------------------|------------------------|
| Result set size | %age accessible nodes | Avg error in 1000 runs |
|-----------------|-----------------------|------------------------|
| 2000            |  5                    |  5.79                  |
| 5000            |  5                    |  9.99                  |
| 10000           |  5                    |  10.938                |
| 100000          |  5                    |  11.13                 |
|                 |                       |                        |
| 2000            | 25                    | 2.4192004              |
| 5000            | 25                    | 3.8087976              |
| 10000           | 25                    | 4.096                  |
| 100000          | 25                    | 4.3699985              |
|                 |                       |                        |
| 2000            | 50                    | 1.3990011              |
| 5000            | 50                    | 2.2695997              |
| 10000           | 50                    | 2.5303981              |
| 100000          | 50                    | 2.594599               |
|                 |                       |                        |
| 2000            | 75                    | 0.80360085             |
| 5000            | 75                    | 1.1929348              |
| 10000           | 75                    | 1.4357346              |
| 100000          | 75                    | 1.4272015              |
|                 |                       |                        |
| 2000            | 95                    | 0.30958                |
| 5000            | 95                    | 0.52715933             |
| 10000           | 95                    | 0.5109484              |
| 100000          | 95                    | 0.5481065              |
|-----------------|-----------------------|------------------------|
</code></pre></div>
<p><img src="../img/facets-statistical-error-rate-plot.png" alt="error rate plot" /></p>
<p>Notice that error rate does increase with large result set sizes but it flattens after around 10000 results. Also, note
that even with 50% results being accessible, error rate averages at less that 3%.</p>
<p>So, in most cases, sampling size of 1000 should give fairly decent estimation of facet counts. On the off chance that
the setup is such that error rates are intolerable, sample size can be configured with <i>sampleSize</i> property under
<i>facets</i> configuration node. Error rates are generally inversely proportional to <code>&#x221a;sample-size</code>. So, to reduce error
rate by 1/2 sample size needs to increased 4 times.</p>
<p>Canonical example of <code>statistical</code> configuration would look like:</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/lucene-with-statistical-facets
  + facets
    - secure = &quot;statistical&quot;
    - sampleSize = 1500
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + tags
          - facets = true
          - propertyIndex = true
</code></pre></div>
<p>See <a href="query-engine.html#Facets">query-engine</a> regarding how to query to evaluate facets alongwith. Also check out
some examples of queries and required index definitions for faceting in <a href="#uc5">use case 5</a>.</p></section><section>
<h4><a name="Score_Explanation"></a><a name="score-explanation"></a>Score Explanation</h4>
<p><code>@since Oak 1.3.12</code></p>
<p>Lucene supports <a class="externalLink" href="https://lucene.apache.org/core/4_6_0/core/org/apache/lucene/search/IndexSearcher.html#explain%28org.apache.lucene.search.Query,%20int%29">explanation of scores</a> which can be selected in a query using a virtual column <code>oak:scoreExplanation</code>.
e.g. <code>select [oak:scoreExplanation], * from [nt:base] where foo='bar'</code></p>
<p><i>Note that showing explanation score is expensive. So, this feature should be used for debug purposes only</i>.</p></section><section>
<h4><a name="Custom_hooks"></a><a name="custom-hooks"></a>Custom hooks</h4>
<p><code>@since Oak 1.3.14</code></p>
<p>The following features is now deprecated:
In OSGi environment, implementations of <code>IndexFieldProvider</code> and <code>FulltextQueryTermsProvider</code> under
<code>org.apache.jackrabbit.oak.plugins.index.lucene.spi</code> (see javadoc <a class="externalLink" href="http://www.javadoc.io/doc/org.apache.jackrabbit/oak-lucene/">here</a>) are called during indexing
and querying as documented in javadocs.</p></section></section><section>
<h3><a name="Search_by_similar_feature_vectors"></a><a name="similar-fv"></a>Search by similar feature vectors</h3>
<p>Oak Lucene index currently supports <i>rep:similar</i> queries via <i>MoreLikeThis</i> for text properties, this allows to search
for similar nodes by looking at texts.
This capability extends <i>rep:similar</i> support to feature vectors, typically used to represent binary content like images,
in order to search for similar nodes by looking at such vectors.</p>
<p>In order to index JCR properties holding vector values for similarity search, either in form of blobs or in form of texts,
the index definition should have a rule for each such property with the <i>useInSimilarity</i> parameter set to <i>true</i>.
As a result, after (re)indexing, each vector will be indexed so that an approximate nearest neighbour search is possible,
not requiring brute force nearest neighbour search over the entire set of indexed vectors.</p>
<p>By default, another property for feature vector similarity search, called <i>similarityRerank</i>, is set to <i>true</i> in order
to allow reranking of the top 15 results using brute force nearest neighbour.
Therefore, in a first iteration an approximate nearest neighbour search is performed to obtain all the possibly relevant
results (expecting high recall), then a brute force nearest neighbour over the top 15 search results is performed to
improve precision (see <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-7824">OAK-7824</a>, <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-7962">OAK-7962</a>,
<a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-8119">OAK-8119</a>).</p>
<p>As a further improvement for the accuracy of similarity search results if nodes having feature vectors also have properties
holding text values that can be used as keywords or tags that well describe the feature vector contents, the
<i>similarityTags</i> configuration can be set to <i>true</i> for such properties (see <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-8118">OAK-8118</a>).</p>
<p>See also <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-7575">OAK-7575</a>.</p>
<p><code>@since Oak 1.8.8</code></p></section><section>
<h3><a name="Design_Considerations"></a><a name="design-considerations"></a>Design Considerations</h3>
<p>Lucene index provides quite a few features to meet various query requirements.
While defining the index definition do consider the following aspects</p>
<ol style="list-style-type: decimal">

<li>

<p>If query uses different path restrictions keeping other restrictions
same then make use of <code>evaluatePathRestrictions</code></p>
</li>
<li>

<p>If query performs sorting then have an explicit property definition for
the property on which sorting is being performed and set <code>ordered</code> to true
for that property</p>
</li>
<li>

<p>If the query is based on specific nodeType then define <code>indexRules</code> for that
nodeType</p>
</li>
<li>

<p>Aim for a precise index configuration which indexes just the right amount of content
based on your query requirement. An index which is precise would be smaller and
would perform better.</p>
</li>
<li>

<p><b>Make use of nodetype to achieve a <i>cohesive</i> index</b>. This would allow multiple
queries to make use of same index and also evaluation of multiple property
restrictions natively in Lucene</p>
</li>
<li>

<p><b><a href="#non-root-index">Non root indexes</a></b> - If your query always
perform search under certain paths then create index definition under those
paths only. This might be helpful in multi tenant deployment where each tenant
data is stored under specific repository path and all queries are made under
those path.</p>
<p>In fact, it's recommended to use single index if all the properties being indexed
are related. This would enable Lucene index to evaluate as much property
restriction as possible natively (which is faster) and also save on storage
cost incurred in storing the node path.</p>
</li>
<li>

<p>Use features when required - There are certain features provided by Lucene
index which incur extra cost in terms of storage space when enabled. For
example enabling <code>evaluatePathRestrictions</code>, <code>ordering</code> etc. Enable such
option only when you make use of those features and further enable them for
only those properties. So <code>ordering</code> should be enabled only when sorting is
being performed for those properties and <code>evaluatePathRestrictions</code> should
only be enabled if you are going to specify path restrictions.</p>
</li>
<li>

<p><b>Avoid overlapping index definition</b> - Do not have overlapping index definition
indexing same nodetype but having different <code>includedPaths</code> and <code>excludedPaths</code>.
Index selection logic does not make use of the <code>includedPaths</code> and <code>excludedPaths</code>
for index selection. Index selection is done only on cost basis and <code>queryPaths</code>.
Having multiple definition for same type would cause ambiguity in index selection
and may lead to unexpected results. Instead, have a single index definition for same
type.</p>
</li>
</ol>
<p>Following analogy might be helpful to people coming from RDBMS world. Treat your
nodetype as Table in your DB and all the direct or relative properties as columns
in that table. Various property definitions can then be considered as index for
those columns.</p></section><section>
<h3><a name="Limits"></a><a name="limits"></a>Limits</h3>
<p>The Apache Lucene version currently used in Oak has a limit of about 2^31 documents per index
(<a class="externalLink" href="http://lucene.apache.org/core/6_5_0/core/org/apache/lucene/codecs/lucene62/package-summary.html#Limitations">this includes Lucene version 6</a>).
If a larger index is needed, please use Apache Solr, which doesn't have this limit.</p></section><section>
<h3><a name="Examples"></a><a name="examples"></a>Examples</h3>
<p>Have a look at <a href="#generate-index-definition">generating index definition</a> for some tooling details
which simplify generating index definition for given set of queries</p><section>
<h4><a name="A_-_Simple_queries"></a><a name="simple-queries"></a>A - Simple queries</h4>
<p>In many cases the query is purely based on some specific property and is not
restricted to any specific nodeType</p>

<div class="source"><pre class="prettyprint"><code>SELECT
  *
FROM [nt:base] AS s
WHERE ISDESCENDANTNODE([/content/public/platform])
AND s.code = 'DRAFT'
</code></pre></div>
<p>Following index definition would allow using Lucene index for above query</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  - evaluatePathRestrictions = true
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + code
          - propertyIndex = true
          - name = &quot;code&quot;
</code></pre></div>
<p>Above definition</p>
<ul>

<li>Indexes <code>code</code> property present on any node</li>
<li>Supports evaluation of path restriction i.e. <code>ISDESCENDANTNODE([/content/public/platform])</code>
via <code>evaluatePathRestrictions</code></li>
<li>Has a single indexRule for <code>nt:base</code> as queries do not specify any explicit
nodeType restriction</li>
</ul>
<p>Now you have another query like</p>

<div class="source"><pre class="prettyprint"><code>SELECT
  *
FROM [nt:base] AS s
WHERE
  s.status = 'DONE'
</code></pre></div>
<p>Here we can either add another property to the above definition or create a new
index definition altogether. By default, prefer to club such indexes together</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  - evaluatePathRestrictions = true
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + code
          - propertyIndex = true
          - name = &quot;code&quot;
        + status
          - propertyIndex = true
          - name = &quot;status&quot;
</code></pre></div>
<p>Taking another example. Lets say you perform a range query like</p>

<div class="source"><pre class="prettyprint"><code>SELECT
  [jcr:path],
  [jcr:score],
  *
FROM [nt:base] AS a
WHERE isdescendantnode(a, '/content')
AND [offTime] &gt; CAST('2015-04-06T02:28:33.032-05:00' AS date)
</code></pre></div>
<p>This can also be clubbed in same index definition above</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  - evaluatePathRestrictions = true
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + code
          - propertyIndex = true
          - name = &quot;code&quot;
        + status
          - propertyIndex = true
          - name = &quot;status&quot;
        + offTime
          - propertyIndex = true
          - name = &quot;offTime&quot;
</code></pre></div></section><section>
<h4><a name="B_-_Queries_for_structured_content"></a><a name="queries-structured-content"></a>B - Queries for structured content</h4>
<p>Queries in previous examples were based on mostly unstructured content where no
nodeType restrictions were applied. However, in many cases the nodes being queried
confirm to certain structure. For example, you have the following content</p>

<div class="source"><pre class="prettyprint"><code>/content/dam/assets/december/banner.png
  - jcr:primaryType = &quot;app:Asset&quot;
  + jcr:content
    - jcr:primaryType = &quot;app:AssetContent&quot;
    + metadata
      - dc:format = &quot;image/png&quot;
      - status = &quot;published&quot;
      - jcr:lastModified = &quot;2009-10-9T21:52:31&quot;
      - app:tags = [&quot;properties:orientation/landscape&quot;, &quot;marketing:interest/product&quot;]
      - size = 450
      - comment = &quot;Image for december launch&quot;
      - jcr:title = &quot;December Banner&quot;
      + xmpMM:History
        + 1
          - softwareAgent = &quot;Adobe Photoshop&quot;
          - author = &quot;David&quot;
    + renditions (nt:folder)
      + original (nt:file)
        + jcr:content
          - jcr:data = ...
</code></pre></div>
<p>Content like above is then queried in multiple ways. So lets take first query</p>
<p><a name="uc1"></a>
<b>UC1 - Find all assets which are having <code>status</code> as <code>published</code></b></p>

<div class="source"><pre class="prettyprint"><code>SELECT * FROM [app:Asset] AS a
WHERE a.[jcr:content/metadata/status] = 'published'
</code></pre></div>
<p>For this following index definition would have to be created</p>

<div class="source"><pre class="prettyprint"><code>/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + status
          - propertyIndex = true
          - name = &quot;jcr:content/metadata/status&quot;
</code></pre></div>
<p>Above index definition</p>
<ul>

<li>Indexes all nodes of type <code>app:Asset</code> <b>only</b></li>
<li>Indexes relative property <code>jcr:content/metadata/status</code> for all such nodes</li>
</ul>
<p><a name="uc2"></a>
<b>UC2 - Find all assets which are having <code>status</code> as <code>published</code> sorted by last
modified date</b></p>

<div class="source"><pre class="prettyprint"><code>SELECT * FROM [app:Asset] AS a
WHERE a.[jcr:content/metadata/status] = 'published'
ORDER BY a.[jcr:content/metadata/jcr:lastModified] DESC
</code></pre></div>
<p>To enable above query the index definition needs to be updated to following</p>

<div class="source"><pre class="prettyprint"><code>    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + status
          - propertyIndex = true
          - name = &quot;jcr:content/metadata/status&quot;
        + lastModified
          - propertyIndex = true
          - name = &quot;jcr:content/metadata/jcr:lastModified&quot;
          - ordered = true
          - type = Date
</code></pre></div>
<p>Above index definition</p>
<ul>

<li><code>jcr:content/metadata/jcr:lastModified</code> is marked as <b><code>ordered</code></b> enabling
support <i>order by</i> evaluation i.e. sorting for such properties</li>
<li>Property type is set to <code>Date</code></li>
<li>Indexes both <code>status</code> and <code>jcr:lastModified</code></li>
</ul>
<p><a name="uc3"></a>
<b>UC3 - Find all assets where comment contains <i>december</i></b></p>

<div class="source"><pre class="prettyprint"><code>SELECT * FROM [app:Asset]
WHERE CONTAINS([jcr:content/metadata/comment], 'december')
</code></pre></div>
<p>To enable above query the index definition needs to be updated to following</p>

<div class="source"><pre class="prettyprint"><code>    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + comment
          - name = &quot;jcr:content/metadata/comment&quot;
          - analyzed = true
</code></pre></div>
<p>Above index definition</p>
<ul>

<li><code>jcr:content/metadata/comment</code> is marked as <b><code>analyzed</code></b> enabling
evaluation of <code>contains</code> i.e. fulltext search</li>
<li><code>propertyIndex</code> is not enabled as this property is not going to be used to
perform equality check</li>
</ul>
<p><a name="uc4"></a>
**UC4 - Find all assets which are created by David and refer to december **</p>

<div class="source"><pre class="prettyprint"><code>SELECT * FROM [app:Asset]
WHERE CONTAINS(., 'december david')
</code></pre></div>
<p>Here we want to create a fulltext index for all assets. It would index all the
properties in <code>app:Asset</code> including all relative nodes. To enable that we need to
make use of <a href="#aggregation">aggregation</a></p>

<div class="source"><pre class="prettyprint"><code>/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + aggregates
    + app:Asset
      + include0
        - path = &quot;jcr:content&quot;
      + include1
        - path = &quot;jcr:content/metadata&quot;
      + include2
        - path = &quot;jcr:content/metadata/*&quot;
      + include3
        - path = &quot;jcr:content/metadata/*/*&quot;
      + include4
        - path = &quot;jcr:content/renditions&quot;
      + include5
        - path = &quot;jcr:content/renditions/original&quot;
    + nt:file
      + include0
        - path = &quot;jcr:content&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + app:Asset
      - includePropertyTypes = [&quot;String&quot;, &quot;Binary&quot;]
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + comment
          - propertyIndex = true
          - nodeScopeIndex = true
          - name = &quot;jcr:content/metadata/comment&quot;
</code></pre></div>
<p>Above index definition</p>
<ul>

<li>

<p>Only indexes <code>String</code> and <code>Binary</code> properties as part of fulltext index via
<b><code>includePropertyTypes</code></b></p>
</li>
<li>

<p>Has <code>aggregates</code> defined for various relative paths like <i>jcr:content</i>,
<i>jcr:content/metadata</i>, <i>jcr:content/renditions/original</i> etc.</p>
<p>With these rules properties like <i>banner.png/metadata/comment</i>,
<i>banner.png/metadata/xmpMM:History/1/author</i> get indexed as part for fulltext
index for <i>banner.png</i> node.</p>
</li>
<li>

<p>Inclusion of <i>jcr:content/renditions/original</i> would lead to aggregation of
<i>jcr:content/renditions/original/jcr:content/jcr:data</i> property also as
aggregation logic would apply rules for <code>nt:file</code> while aggregating the
<code>original</code> node</p>
</li>
<li>

<p>Aggregation would include by default all properties which are part of
<b><code>includePropertyTypes</code></b>. However, if any property has an explicit property
definition provided like <code>comment</code> then <code>nodeScopeIndex</code> would need to be
set to true</p>
</li>
</ul>
<p>Above definition would allow fulltext query to be performed. But we can do more.
Suppose you want to give more preference to those nodes where the fulltext term
is found in <code>jcr:title</code> compared to any other field. In such cases we can <code>boost</code>
such fields</p>

<div class="source"><pre class="prettyprint"><code>  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + comment
          - propertyIndex = true
          - nodeScopeIndex = true
          - name = &quot;jcr:content/metadata/comment&quot;
        + title
          - propertyIndex = true
          - nodeScopeIndex = true
          - name = &quot;jcr:content/metadata/jcr:title&quot;
          - boost = 2.0
</code></pre></div><section>
<h5><a name="UC5_-_Facets"></a><a name="uc5"></a>UC5 - Facets</h5>
<p>Unconstrained queries for facets like</p>

<div class="source"><pre class="prettyprint"><code>    SELECT [rep:facet(title)] FROM [app:Asset]
or
    /jcr:root//element(*, app:Asset)/(rep:facet(title))
or
    SELECT [rep:facet(title)], [rep:facet(tags)] FROM [app:Asset]
or
    /jcr:root//element(*, app:Asset)/(rep:facet(title) | rep:facet(tags))
</code></pre></div>
<p>would require an index on <code>app:Asset</code>  containing all nodes of the type. That, in
turn, means that either the index needs to be a fulltext index or needs to be
indexing <code>jcr:primaryType</code> property. All the following definitions would work
for such a case:</p>

<div class="source"><pre class="prettyprint"><code>   + /oak:index/index1
      - ...
      + aggregates
        + app:Asset
          + include0
            - path = &quot;jcr:content&quot;
      + indexRules
        + app:Asset
          + properties
            + title
              - facets = true
            + tags
              - facets = true
              - propertyIndex = true
or
   + /oak:index/index2
      - ...
      + indexRules
        + app:Asset
          + properties
            + title
              - facets = true
              - nodeScopeIndex = true
            + tags
              - facets = true
              - propertyIndex = true
or
   + /oak:index/index3
      - ...
      + indexRules
        + app:Asset
          + properties
            + nodeType
              - propertyIndex = true
              - name = jcr:primaryType
            + title
              - facets = true
            + tags
              - facets = true
</code></pre></div>
<p>Another thing to note with facets is that facet counts are derived from lucene index.
While not immediately obvious, that implies that any constraint on the query that do
<b>not</b> get evaluated by the index are going to return incorrect facet counts as the other
constraints would get filtered <i>after</i> collecting counts from the index.</p>
<p>So, following queries require correspondingly listed indexes:</p>

<div class="source"><pre class="prettyprint"><code>SELECT rep:facet(title) FROM [app:Asset] WHERE ISDESCENDANTNODE('/some/path')

+ /oak:index/index2
  - ...
  - evaluatePathRestrictions = true
  + indexRules
    + app:Asset
      + properties
        + title
          - facets = true
          - propertyIndex = true
</code></pre></div>

<div class="source"><pre class="prettyprint"><code>SELECT rep:facet(title) FROM [app:Asset] WHERE CONTAINS(., 'foo')

+ /oak:index/index2
  - ...
  + indexRules
    + app:Asset
      + properties
        + title
          - facets = true
          - propertyIndex = true
          - nodeScopeIndex = true
</code></pre></div>

<div class="source"><pre class="prettyprint"><code>SELECT rep:facet(title) FROM [app:Asset] WHERE [title] IS NOT NULL

+ /oak:index/index2
  - ...
  + indexRules
    + app:Asset
      + properties
        + title
          - facets = true
          - propertyIndex = true
</code></pre></div></section></section></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
<p>&#169; 2012-2024
<a href="https://www.apache.org/">The Apache Software Foundation</a> &vert; <a href="https://privacy.apache.org/policies/privacy-policy-public.html">Privacy Policy</a>
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>