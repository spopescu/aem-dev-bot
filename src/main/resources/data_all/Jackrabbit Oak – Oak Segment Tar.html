<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/markdown/nodestore/segment/overview.md at 2024-06-11
 | Rendered using Apache Maven Fluido Skin 1.11.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>Jackrabbit Oak &#x2013; Oak Segment Tar</title>
    <link rel="stylesheet" href="../../css/apache-maven-fluido-1.11.1.min.css" />
    <link rel="stylesheet" href="../../css/site.css" />
    <link rel="stylesheet" href="../../css/print.css" media="print" />
    <script src="../../js/apache-maven-fluido-1.11.1.min.js"></script>

    <!-- Matomo -->
    <script>
        var _paq = window._paq = window._paq || [];
                _paq.push(['disableCookies']);
                    _paq.push(['trackPageView']);
                    _paq.push(['enableLinkTracking']);
        
        (function() {
            var u="https://analytics.apache.org";
            _paq.push(['setTrackerUrl', u+'/matomo.php']);
            _paq.push(['setSiteId', '4']);
            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
            g.async=true; g.src=u+'/matomo.js'; s.parentNode.insertBefore(g,s);
        })();
    </script>
    <!-- End Matomo Code -->
  </head>
  <body class="topBarEnabled">
    <a class="github-fork-ribbon right-top" href="https://github.com/apache/jackrabbit-oak" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
    <header id="topbar" class="navbar navbar-fixed-top ">
      <div class="navbar-inner">
        <div class="container-fluid">
        <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
<a class="brand" href="../../"  title="Oak logo"><img src="../../oak_logo.png" alt="Oak logo" />
</a>
            <ul class="nav">
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Overview <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../../index.html" title="Jackrabbit Oak">Jackrabbit Oak</a></li>
            <li><a href="../../license.html" title="License">License</a></li>
            <li><a href="../../downloads.html" title="Downloads">Downloads</a></li>
            <li><a href="../../roadmap.html" title="Roadmap">Roadmap</a></li>
            <li><a href="../../articles.html" title="Articles">Articles</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Concepts and Architecture <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../../architecture/overview.html" title="Overview">Overview</a></li>
            <li><a href="../../architecture/nodestate.html" title="The Node State Model">The Node State Model</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Main APIs <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="https://s.apache.org/jcr-2.0-spec/index.html" title="JCR API">JCR API</a></li>
            <li><a href="https://jackrabbit.apache.org/jcr/jcr-api.html" title="Jackrabbit API">Jackrabbit API</a></li>
            <li><a href="../../oak_api/overview.html" title="Oak API">Oak API</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Features and Plugins <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li class="dropdown-submenu">
<a href="../../nodestore/overview.html" title="Node Storage">Node Storage</a>
              <ul class="dropdown-menu">
                  <li><a href="../../nodestore/documentmk.html" title="Document NodeStore">Document NodeStore</a></li>
                  <li><a title="Segment NodeStore">Segment NodeStore</a></li>
                  <li><a href="../../nodestore/compositens.html" title="Composite NodeStore">Composite NodeStore</a></li>
              </ul>
            </li>
            <li class="dropdown-submenu">
<a href="../../plugins/blobstore.html" title="Blob Storage">Blob Storage</a>
              <ul class="dropdown-menu">
                  <li><a href="../../features/direct-binary-access.html" title="Direct Binary Access">Direct Binary Access</a></li>
                  <li><a href="../../features/direct-binary-access-upload-file.html" title="Direct Binary Access Upload File">Direct Binary Access Upload File</a></li>
              </ul>
            </li>
            <li class="dropdown-submenu">
<a href="../../query/query.html" title="Query">Query</a>
              <ul class="dropdown-menu">
                  <li><a href="../../query/query-engine.html" title="Query Engine">Query Engine</a></li>
                  <li><a href="../../query/grammar-xpath.html" title="XPath Grammar">XPath Grammar</a></li>
                  <li><a href="../../query/grammar-sql2.html" title="SQL-2 Grammar">SQL-2 Grammar</a></li>
                  <li><a href="../../query/query-troubleshooting.html" title="Troubleshooting">Troubleshooting</a></li>
                  <li><a href="../../query/indexing.html" title="Indexing">Indexing</a></li>
                  <li><a href="../../query/oak-run-indexing.html" title="Indexing with Oak-Run">Indexing with Oak-Run</a></li>
                  <li><a href="../../query/lucene.html" title="Lucene Index">Lucene Index</a></li>
                  <li><a href="../../query/elastic.html" title="Elastic Index">Elastic Index</a></li>
                  <li><a href="../../query/property-index.html" title="Property Index">Property Index</a></li>
                  <li><a href="../../query/hybrid-index.html" title="Hybrid Index">Hybrid Index</a></li>
                  <li><a href="../../query/solr.html" title="Solr Index">Solr Index</a></li>
              </ul>
            </li>
            <li class="dropdown-submenu">
<a href="../../security/overview.html" title="Security">Security</a>
              <ul class="dropdown-menu">
                  <li><a href="../../security/introduction.html" title="Introduction">Introduction</a></li>
                  <li><a href="../../security/reports.html" title="Reports">Reports</a></li>
                  <li><a href="../../security/authentication.html" title="Authentication">Authentication</a></li>
                  <li><a href="../../security/authorization.html" title="Authorization">Authorization</a></li>
                  <li><a href="../../security/principal.html" title="Principal Management">Principal Management</a></li>
                  <li><a href="../../security/user.html" title="User Management">User Management</a></li>
              </ul>
            </li>
            <li><a href="../../features/atomic-counter.html" title="Atomic Counter">Atomic Counter</a></li>
            <li><a href="../../features/observation.html" title="Observation">Observation</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Using Oak <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../../use_getting_started.html" title="Getting Started">Getting Started</a></li>
            <li><a href="../../construct.html" title="Repository Construction">Repository Construction</a></li>
            <li><a href="../../osgi_config.html" title="Configuring Oak">Configuring Oak</a></li>
            <li><a href="../../command_line.html" title="Command Line Tools">Command Line Tools</a></li>
            <li><a href="../../migration.html" title="Migration">Migration</a></li>
            <li><a href="../../differences.html" title="Differences to Jackrabbit 2">Differences to Jackrabbit 2</a></li>
            <li><a href="../../known_issues.html" title="Known Issues">Known Issues</a></li>
            <li><a href="../../constraints.html" title="Constraints">Constraints</a></li>
            <li><a href="../../dos_and_donts.html" title="Dos and Don'ts">Dos and Don'ts</a></li>
            <li><a href="../../coldstandby/coldstandby.html" title="Cold Standby">Cold Standby</a></li>
            <li><a href="../../FAQ.html" title="FAQ">FAQ</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Developing Oak <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../../dev_getting_started.html" title="Getting Started">Getting Started</a></li>
            <li><a href="../../participating.html" title="Participating">Participating</a></li>
            <li><a href="../../testing.html" title="Testing">Testing</a></li>
            <li><a href="../../oakathons.html" title="Oakathons">Oakathons</a></li>
            <li><a href="../../developing-with-git.html" title="Developing with Git">Developing with Git</a></li>
            <li><a href="../../diagnostic-builds.html" title="Cutting diagnostic builds">Cutting diagnostic builds</a></li>
            <li><a href="../../branching.html" title="Branching off a new stable">Branching off a new stable</a></li>
            <li><a href="../../attribution.html" title="Attribution">Attribution</a></li>
            <li><a href="../../release-schedule.html" title="Release Schedule">Release Schedule</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown">Links <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="http://jackrabbit.apache.org/oak" title="Apache Jackrabbit Oak">Apache Jackrabbit Oak</a></li>
            <li><a href="http://jackrabbit.apache.org/" title="Apache Jackrabbit">Apache Jackrabbit</a></li>
        </ul>
      </li>
            </ul>
        </div>
      </div>
    </header>
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>Oak Documentation</h1>
</div>
</div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
      <li class=""><a href="https://jackrabbit.apache.org/" class="externalLink" title="Jackrabbit">Jackrabbit</a><span class="divider">/</span></li>
      <li class=""><a href="https://jackrabbit.apache.org/oak/docs/" class="externalLink" title="Oak">Oak</a><span class="divider">/</span></li>
    <li class="active ">Oak Segment Tar <a href="https://github.com/apache/jackrabbit-oak/edit/trunk/oak-doc/src/site/markdown/nodestore/segment/overview.md"><img src="../../images/accessories-text-editor.png" title="Edit" /></a></li>
        <li id="publishDate" class="pull-right">Last Published: 2024-06-11</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li><a href="../../index.html" title="Jackrabbit Oak"><span class="none"></span>Jackrabbit Oak</a></li>
    <li><a href="../../license.html" title="License"><span class="none"></span>License</a></li>
    <li><a href="../../downloads.html" title="Downloads"><span class="none"></span>Downloads</a></li>
    <li><a href="../../roadmap.html" title="Roadmap"><span class="none"></span>Roadmap</a></li>
    <li><a href="../../articles.html" title="Articles"><span class="none"></span>Articles</a></li>
   <li class="nav-header">Concepts and Architecture</li>
    <li><a href="../../architecture/overview.html" title="Overview"><span class="none"></span>Overview</a></li>
    <li><a href="../../architecture/nodestate.html" title="The Node State Model"><span class="none"></span>The Node State Model</a></li>
   <li class="nav-header">Main APIs</li>
    <li><a href="https://s.apache.org/jcr-2.0-spec/index.html" class="externalLink" title="JCR API"><span class="none"></span>JCR API</a></li>
    <li><a href="https://jackrabbit.apache.org/jcr/jcr-api.html" class="externalLink" title="Jackrabbit API"><span class="none"></span>Jackrabbit API</a></li>
    <li><a href="../../oak_api/overview.html" title="Oak API"><span class="none"></span>Oak API</a></li>
   <li class="nav-header">Features and Plugins</li>
    <li><a href="../../nodestore/overview.html" title="Node Storage"><span class="icon-chevron-down"></span>Node Storage</a>
     <ul class="nav nav-list">
      <li><a href="../../nodestore/documentmk.html" title="Document NodeStore"><span class="icon-chevron-down"></span>Document NodeStore</a>
       <ul class="nav nav-list">
        <li><a href="../../nodestore/document/mongo-document-store.html" title="MongoDB DocumentStore"><span class="none"></span>MongoDB DocumentStore</a></li>
        <li><a href="../../nodestore/document/rdb-document-store.html" title="RDB DocumentStore"><span class="none"></span>RDB DocumentStore</a></li>
        <li><a href="../../nodestore/document/node-bundling.html" title="Node Bundling"><span class="none"></span>Node Bundling</a></li>
        <li><a href="../../nodestore/document/secondary-store.html" title="Secondary Store"><span class="none"></span>Secondary Store</a></li>
        <li><a href="../../nodestore/persistent-cache.html" title="Persistent Cache"><span class="none"></span>Persistent Cache</a></li>
        <li><a href="../../clustering.html" title="Clustering"><span class="none"></span>Clustering</a></li>
       </ul></li>
      <li class="active"><a><span class="none"></span>Segment NodeStore</a></li>
      <li><a href="../../nodestore/compositens.html" title="Composite NodeStore"><span class="none"></span>Composite NodeStore</a></li>
     </ul></li>
    <li><a href="../../plugins/blobstore.html" title="Blob Storage"><span class="icon-chevron-down"></span>Blob Storage</a>
     <ul class="nav nav-list">
      <li><a href="../../features/direct-binary-access.html" title="Direct Binary Access"><span class="none"></span>Direct Binary Access</a></li>
      <li><a href="../../features/direct-binary-access-upload-file.html" title="Direct Binary Access Upload File"><span class="none"></span>Direct Binary Access Upload File</a></li>
     </ul></li>
    <li><a href="../../query/query.html" title="Query"><span class="icon-chevron-down"></span>Query</a>
     <ul class="nav nav-list">
      <li><a href="../../query/query-engine.html" title="Query Engine"><span class="none"></span>Query Engine</a></li>
      <li><a href="../../query/grammar-xpath.html" title="XPath Grammar"><span class="none"></span>XPath Grammar</a></li>
      <li><a href="../../query/grammar-sql2.html" title="SQL-2 Grammar"><span class="none"></span>SQL-2 Grammar</a></li>
      <li><a href="../../query/query-troubleshooting.html" title="Troubleshooting"><span class="none"></span>Troubleshooting</a></li>
      <li><a href="../../query/indexing.html" title="Indexing"><span class="none"></span>Indexing</a></li>
      <li><a href="../../query/oak-run-indexing.html" title="Indexing with Oak-Run"><span class="none"></span>Indexing with Oak-Run</a></li>
      <li><a href="../../query/lucene.html" title="Lucene Index"><span class="none"></span>Lucene Index</a></li>
      <li><a href="../../query/elastic.html" title="Elastic Index"><span class="none"></span>Elastic Index</a></li>
      <li><a href="../../query/property-index.html" title="Property Index"><span class="none"></span>Property Index</a></li>
      <li><a href="../../query/hybrid-index.html" title="Hybrid Index"><span class="none"></span>Hybrid Index</a></li>
      <li><a href="../../query/solr.html" title="Solr Index"><span class="none"></span>Solr Index</a></li>
     </ul></li>
    <li><a href="../../security/overview.html" title="Security"><span class="icon-chevron-down"></span>Security</a>
     <ul class="nav nav-list">
      <li><a href="../../security/introduction.html" title="Introduction"><span class="none"></span>Introduction</a></li>
      <li><a href="../../security/reports.html" title="Reports"><span class="none"></span>Reports</a></li>
      <li><a href="../../security/authentication.html" title="Authentication"><span class="icon-chevron-right"></span>Authentication</a></li>
      <li><a href="../../security/authorization.html" title="Authorization"><span class="icon-chevron-right"></span>Authorization</a></li>
      <li><a href="../../security/principal.html" title="Principal Management"><span class="icon-chevron-right"></span>Principal Management</a></li>
      <li><a href="../../security/user.html" title="User Management"><span class="icon-chevron-right"></span>User Management</a></li>
     </ul></li>
    <li><a href="../../features/atomic-counter.html" title="Atomic Counter"><span class="none"></span>Atomic Counter</a></li>
    <li><a href="../../features/observation.html" title="Observation"><span class="none"></span>Observation</a></li>
   <li class="nav-header">Using Oak</li>
    <li><a href="../../use_getting_started.html" title="Getting Started"><span class="none"></span>Getting Started</a></li>
    <li><a href="../../construct.html" title="Repository Construction"><span class="none"></span>Repository Construction</a></li>
    <li><a href="../../osgi_config.html" title="Configuring Oak"><span class="none"></span>Configuring Oak</a></li>
    <li><a href="../../command_line.html" title="Command Line Tools"><span class="none"></span>Command Line Tools</a></li>
    <li><a href="../../migration.html" title="Migration"><span class="none"></span>Migration</a></li>
    <li><a href="../../differences.html" title="Differences to Jackrabbit 2"><span class="none"></span>Differences to Jackrabbit 2</a></li>
    <li><a href="../../known_issues.html" title="Known Issues"><span class="none"></span>Known Issues</a></li>
    <li><a href="../../constraints.html" title="Constraints"><span class="none"></span>Constraints</a></li>
    <li><a href="../../dos_and_donts.html" title="Dos and Don'ts"><span class="none"></span>Dos and Don'ts</a></li>
    <li><a href="../../coldstandby/coldstandby.html" title="Cold Standby"><span class="none"></span>Cold Standby</a></li>
    <li><a href="../../FAQ.html" title="FAQ"><span class="none"></span>FAQ</a></li>
   <li class="nav-header">Developing Oak</li>
    <li><a href="../../dev_getting_started.html" title="Getting Started"><span class="none"></span>Getting Started</a></li>
    <li><a href="../../participating.html" title="Participating"><span class="none"></span>Participating</a></li>
    <li><a href="../../testing.html" title="Testing"><span class="none"></span>Testing</a></li>
    <li><a href="../../oakathons.html" title="Oakathons"><span class="none"></span>Oakathons</a></li>
    <li><a href="../../developing-with-git.html" title="Developing with Git"><span class="none"></span>Developing with Git</a></li>
    <li><a href="../../diagnostic-builds.html" title="Cutting diagnostic builds"><span class="none"></span>Cutting diagnostic builds</a></li>
    <li><a href="../../branching.html" title="Branching off a new stable"><span class="none"></span>Branching off a new stable</a></li>
    <li><a href="../../attribution.html" title="Attribution"><span class="none"></span>Attribution</a></li>
    <li><a href="../../release-schedule.html" title="Release Schedule"><span class="none"></span>Release Schedule</a></li>
   <li class="nav-header">Links</li>
    <li><a href="http://jackrabbit.apache.org/oak" class="externalLink" title="Apache Jackrabbit Oak"><span class="none"></span>Apache Jackrabbit Oak</a></li>
    <li><a href="http://jackrabbit.apache.org/" class="externalLink" title="Apache Jackrabbit"><span class="none"></span>Apache Jackrabbit</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
<form id="search-form" action="https://www.google.com/search" method="get" >
  <input value="jackrabbit.apache.org/oak/docs/" name="sitesearch" type="hidden"/>
  <input class="search-query" name="q" id="query" type="text" placeholder="Search with Google..." />
</form>
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<h1>Oak Segment Tar</h1>
<ul>

<li><a href="#overview">Overview</a></li>
<li><a href="#garbage-collection">Garbage Collection</a>
<ul>

<li><a href="#generational-garbage-collection">Generational Garbage Collection</a></li>
<li><a href="#estimation-compaction-cleanup">Estimation, Compaction and Cleanup</a></li>
<li><a href="#offline-garbage-collection">Offline Garbage Collection</a></li>
<li><a href="#online-garbage-collection">Online Garbage Collection</a></li>
</ul>
</li>
<li><a href="#monitoring">Monitoring</a></li>
<li><a href="#tools">Tools</a>
<ul>

<li><a href="#segment-copy">Segment-Copy</a></li>
<li><a href="#backup">Backup</a></li>
<li><a href="#restore">Restore</a></li>
<li><a href="#check">Check</a></li>
<li><a href="#compact">Compact</a></li>
<li><a href="#debug">Debug</a></li>
<li><a href="#iotrace">IOTrace</a></li>
<li><a href="#diff">Diff</a></li>
<li><a href="#history">History</a></li>
<li><a href="#recover-journal">Recover Journal</a></li>
</ul>
</li>
</ul><section>
<h2><a name="Overview"></a><a name="overview"></a> Overview</h2>
<p>Oak Segment Tar is an Oak storage backend that stores content as various types of <i>records</i> within larger <i>segments</i>. Segments themselves are collected within <i>tar files</i> along with further auxiliary information. A <i>journal</i> is used to track the latest state of the repository. It is based on the following key principles:</p>
<ul>

<li>

<p><i>Immutability</i>. Segments are immutable, which makes is easy to cache frequently accessed segments. This also makes it less likely for programming or system errors to cause repository inconsistencies, and simplifies features like backups or master-slave clustering.</p>
</li>
<li>

<p><i>Compactness</i>. The formatting of records is optimized for size to reduce IO costs and to fit as much content in caches as possible.</p>
</li>
<li>

<p><i>Locality</i>. Segments are written so that related records, like a node and its immediate children, usually end up stored in the same segment. This makes tree traversals very fast and avoids most cache misses for typical clients that access more than one related node per session.</p>
</li>
</ul>
<p>The content tree and all its revisions are stored in a collection of immutable <i>records</i> within <i>segments</i>. Each segment is identified by a UUID and typically contains a continuous subset of the content tree, for example a node with its properties and closest child nodes. Some segments might also be used to store commonly occurring property values or other shared data. Segments can be up to 256KiB in size. See <a href="records.html">Segments and records</a> for a detailed description of the segments and records.</p>
<p>Segments are collectively stored in <i>tar files</i> and check-summed to ensure their integrity. Tar files also contain an index of the tar segments, the graph of segment references of all segments it contains and an index of all external binaries referenced from the segments in the tar file. See <a href="tar.html">Structure of TAR files</a> for details.</p>
<p>The <i>journal</i> is a special, atomically updated file that records the state of the repository as a sequence of references to successive root node records. For crash resiliency the journal is always only updated with a new reference once the referenced record has been flushed to disk.  The most recent root node reference stored in the journal is used as the starting point for garbage collection. All content currently visible to clients must be accessible through that reference.</p>
<p>Oak Segment Tar is an evolution of a <a href="../segmentmk.html">previous implementation</a>. Upgrading requires <a href="../../migration.html">migrating</a> to the <a href="changes.html">new storage format</a>.</p>
<p>See <a href="classes.html">Design of Oak Segment Tar</a> for a high level design overview of Oak Segment Tar.</p></section><section>
<h2><a name="Garbage_Collection"></a><a name="garbage-collection"></a> Garbage Collection</h2>
<p>Garbage Collection is the set of processes and techniques employed by Oak Segment Tar to eliminate unused persisted data, thus limiting the memory and disk footprint of the system.
Most of the operations on repository data generate a certain amount of garbage.
This garbage is a byproduct of the repository operations and consists of leftover data that is not usable by the user.
If left unchecked, this garbage would just pile up, consume disk space and pollute in-memory data structures.
To avoid this, Oak Segment Tar defines garbage collection procedures to eliminate unnecessary data.
The implementation of garbage collection in Oak evolved heavily between Oak 1.0 and Oak 1.8. See <a href="onrc-memoirs.html">Memoirs in Garbage Collection</a> for an historical account.</p><section>
<h3><a name="Generational_Garbage_Collection"></a><a name="generational-garbage-collection"></a> Generational Garbage Collection</h3>
<p>The process implemented by Oak Segment Tar to eliminate unnecessary data is a generational garbage collection algorithm.
The idea behind this algorithm is that the system assigns a generation to every piece of data generated by the user.
A generation is just a number that is monotonically increasing.</p>
<p>When the system first starts, every piece of data created by the user belongs to the first generation.
When garbage collection runs, a second generation is started.
As soon as the second generation is in place, data from the first generation that is still used by the user is copied over to the second generation.
From this moment on, new data will be assigned to the second generation.
Now the system contains data from the first and the second generation, but only data from the second generation is used.
The garbage collector can now remove every piece of data from the first generation.
This removal is safe, because every piece of data that is still in use was copied to the second generation when garbage collection started.</p>
<p>The process of creating a new generation, migrating data to the new generation and removing an old generation is usually referred to as a &#x201c;garbage collection cycle&#x201d;.
The system goes through many garbage collection cycles over its lifetime, where every cycle removes unused data from older generations.</p></section><section>
<h3><a name="Estimation.2C_Compaction_and_Cleanup"></a><a name="estimation-compaction-cleanup"></a> Estimation, Compaction and Cleanup</h3>
<p>While the previous section describes the idea behind garbage collection, this section introduces the building blocks on top of which garbage collection is implemented.
Oak Segment Tar splits the garbage collection process in three phases: estimation, compaction and cleanup.</p>
<p>Estimation is the first phase of garbage collection.
In this phase, the system estimates how much garbage is actually present in the system.
If there is not enough garbage to justify the creation of a new generation, the rest of the garbage collection process is skipped.
If the output of this phase reports that the amount of garbage is beyond a certain threshold, the system creates a new generation and goes on with the next phase.</p>
<p>Compaction executes after a new generation is created.
The purpose of compaction is to create a compact representation of the current generation. For this the current generation is copied to the new generation leaving out anything from the current generation that is not reachable anymore. Starting with Oak 1.8 compaction can operate in either of two modes: full compaction and tail compaction. Full compaction copies all revisions pertaining to the current generation to the new generation. In contrast tail compaction only copies the most recent ones. The two compaction modes differ in usage of system resources and how much time they consume. While full compaction is more thorough overall, it usually requires much more time, disk space and disk IO than tail compaction.</p>
<p>Cleanup is the last phase of garbage collection and kicks in as soon as compaction is done.
Once relevant data is safe in the new generation, old and unused data from a previous generation can be removed.
This phase locates outdated pieces of data from one of the oldest generations and removes it from the system.
This is the only phase where data is actually deleted and disk space is finally freed. The amount of freed disk space depends on the preceding compaction operation. In general cleanup can free less space after a tail compaction than after a full compaction. However, this usually only becomes effective after a further garbage collection cycle as the system retains a total of two generations by default.</p></section><section>
<h3><a name="Offline_Garbage_Collection"></a><a name="offline-garbage-collection"></a> Offline Garbage Collection</h3>
<p>Offline garbage collection is the procedure followed by Oak Segment Tar to execute garbage collection by taking exclusive control of the repository.</p>
<p>Offline garbage collection runs as a standalone Java tool manually or semi-automatically started from the command line.
The way offline garbage collection works is simpler than the online version.
It is assumed that a human operator is in charge of deciding when offline compaction is needed.
In such a case, the human operator has to take offline - hence the name - the system using the repository and start the compaction utility from the command line.</p>
<p>Since offline garbage collection requires human intervention to run, the estimation phase is not executed at all.
The human operator who decides to run offline garbage collection does so because he or she decided that the garbage in the repository is exceeding some arbitrary threshold.
Since the decision comes from a human operator, offline garbage collection is not in charge of implementing heuristics to decide if and when garbage collection should be run.
The offline garbage collection process consist of the compaction and cleanup phases only. It always employs full compaction with the subsequent cleanup retaining a single generation.</p>
<p>The main drawback of offline garbage collection is that the process has to take exclusive control of the repository.
Nevertheless, this is also a strength.
Having exclusive access to the repository, offline garbage collection is usually faster and more effective of its online counterpart.
Because of this, offline garbage collection is (and will always be) an important tool in repository management.</p></section><section>
<h3><a name="Online_Garbage_Collection"></a><a name="online-garbage-collection"></a> Online Garbage Collection</h3>
<p>Online garbage collection is the procedure followed by Oak Segment Tar to execute garbage collection on a running system.
The online garbage collection procedure aims at removing garbage with minimal interruption on the system.
Online garbage collection runs as a background process at regular intervals of time, potentially removing unused data at each iteration.
The main benefit of online garbage collection is that it runs concurrently with other system activities: it does not require the user to shut down the system for it to work.</p><section>
<h4><a name="Monitoring_the_log"></a><a name="monitoring-the-log"></a> Monitoring the log</h4>
<p>Online garbage collection prints lots of useful information to the system log.
This section groups those log messages by function, so to provide a useful reference to understand the different activities performed by online garbage collection.</p>
<p>Please note that the following messages are to be used as an example only.
To make the examples clear, some information like the date and time, the name of the thread, and the name of the logger are removed.
This information depends on the configuration of your logging framework.
Moreover, some of those messages contain data that can and will change from one execution to the other.</p>
<p>Every log message generated during the garbage collection process includes a sequence number
indicating how many times garbage collection ran since the system started.
The sequence number is always printed at the beginning of the message like in the following example.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: ...
</code></pre></div><section>
<h5><a name="When_did_garbage_collection_start.3F"></a><a name="when-did-garbage-collection-start"></a> When did garbage collection start?</h5>
<p>As soon as garbage collection is triggered, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: started
</code></pre></div></section><section>
<h5><a name="When_did_estimation_start.3F"></a><a name="when-did-estimation-start"></a> When did estimation start?</h5>
<p>As soon as the estimation phase of garbage collection starts, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: estimation started
</code></pre></div></section><section>
<h5><a name="Is_estimation_disabled.3F"></a><a name="is-estimation-disabled"></a> Is estimation disabled?</h5>
<p>The estimation phase can be disabled by configuration. If this is the case, the system prints the following message.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: estimation skipped because it was explicitly disabled
</code></pre></div>
<p>Estimation is also skipped when compaction is disabled on the system. In this case, the following message is printed instead.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: estimation skipped because compaction is paused
</code></pre></div></section><section>
<h5><a name="Was_estimation_cancelled.3F"></a><a name="was-estimation-cancelled"></a> Was estimation cancelled?</h5>
<p>The execution of the estimation phase can be cancelled manually by the user or automatically if certain events occur.
If estimation is cancelled, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: estimation interrupted: ${REASON}. Skipping compaction.
</code></pre></div>
<p>The placeholder <code>${REASON}</code> is not actually printed in the message, but will be substituted by a more specific description of the reason that brought estimation to a premature halt.
As stated before, some external events can terminate estimation, e.g. not enough memory or disk space on the host system.
Moreover, estimation can also be cancelled by shutting down the system or by explicitly cancelling it via administrative interfaces.
In each of these cases, the reason why estimation is cancelled will be printed in the log.</p></section><section>
<h5><a name="When_did_estimation_complete.3F"></a><a name="when-did-estimation-complete"></a> When did estimation complete?</h5>
<p>When estimation terminates, either because of external cancellation or after a successful execution, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: estimation completed in 961.8 &#x3bc;s (0 ms). ${RESULT}
</code></pre></div>
<p>Moreover, the duration of the estimation phase is printed both in a readable format and in milliseconds.
The placeholder <code>${RESULT}</code> stands for a message that depends on the estimation strategy.</p></section><section>
<h5><a name="When_did_compaction_start.3F"></a><a name="when-did-compaction-start"></a> When did compaction start?</h5>
<p>When the compaction phase of the garbage collection process starts, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction started, gc options=SegmentGCOptions{paused=false, estimationDisabled=false, gcSizeDeltaEstimation=1, retryCount=5, forceTimeout=3600, retainedGenerations=2, gcSizeDeltaEstimation=1}
</code></pre></div>
<p>The message includes a dump of the garbage collection options that are used during the compaction phase.</p></section><section>
<h5><a name="What_is_the_compaction_type.3F"></a><a name="what-is-the-compaction-type"></a> What is the compaction type?</h5>
<p>The type of the compaction phase is determined by the configuration. A log message indicates which compaction type is used.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: running ${MODE} compaction
</code></pre></div>
<p>Here ${MODE} is either <code>full</code> or <code>tail</code>. Under some circumstances (e.g. on the very first garbage collection run) when a tail compaction is scheduled to run the system needs to fall back to a full compaction. This is indicated in the log via the following message:</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: no base state available, running full compaction instead
</code></pre></div></section><section>
<h5><a name="Is_compaction_disabled.3F"></a><a name="is-compaction-disabled"></a> Is compaction disabled?</h5>
<p>The compaction phase can be skipped by pausing the garbage collection process. If compaction is paused, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction paused
</code></pre></div>
<p>As long as compaction is paused, neither the estimation phase nor the compaction phase will be executed.</p></section><section>
<h5><a name="Was_compaction_cancelled.3F"></a><a name="was-compaction-cancelled"></a> Was compaction cancelled?</h5>
<p>The compaction phase can be cancelled manually by the user or automatically because of external events. If compaction is cancelled, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction cancelled: ${REASON}.
</code></pre></div>
<p>The placeholder <code>${REASON}</code> is not actually printed in the message, but will be substituted by a more specific description of the reason that brought compaction to a premature halt.
As stated before, some external events can terminate compaction, e.g. not enough memory or disk space on the host system.
Moreover, compaction can also be cancelled by shutting down the system or by explicitly cancelling it via administrative interfaces.
In each of these cases, the reason why compaction is cancelled will be printed in the log.</p></section><section>
<h5><a name="When_did_compaction_complete.3F"></a><a name="when-did-compaction-complete"></a> When did compaction complete?</h5>
<p>When compaction complete successfully, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction succeeded in 6.580 min (394828 ms), after 2 cycles
</code></pre></div>
<p>The time shown in the log message is relative to the compaction phase only.
The reference to the amount of cycles spent for the compaction phase is explained in more detail below.
If compaction did not complete successfully, the following message is printed instead.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction failed in 32.902 min (1974140 ms), after 5 cycles
</code></pre></div>
<p>This message doesn't mean that there was an unrecoverable error, but only that compaction gave up after a certain amount of attempts.
In case an error occurs, the following message is printed instead.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction encountered an error
</code></pre></div>
<p>This message is followed by the stack trace of the exception that was caught during the compaction phase.
There is also a special message that is printed if the thread running the compaction phase is interrupted.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction interrupted
</code></pre></div></section><section>
<h5><a name="How_does_compaction_deal_with_checkpoints.3F"></a><a name="how-does-compaction-deal-with-checkpoints"></a> How does compaction deal with checkpoints?</h5>
<p>Since checkpoints share a lot of common data between themselves and between the actual content, compaction handles them individually, deduplicating as much content as possible. The following messages will be printed to the log during the process.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: Found checkpoint 4b2ee46a-d7cf-45e7-93c3-799d538f85e6 created at Wed Nov 29 15:31:43 CET 2017.
TarMK GC #2: Found checkpoint 5c45ca7b-5863-4679-a7c5-6056a999a6cd created at Wed Nov 29 15:31:43 CET 2017.
TarMK GC #2: compacting checkpoints/4b2ee46a-d7cf-45e7-93c3-799d538f85e6/root.
TarMK GC #2: compacting checkpoints/5c45ca7b-5863-4679-a7c5-6056a999a6cd/root.
TarMK GC #2: compacting root.
</code></pre></div></section><section>
<h5><a name="How_does_compaction_make_use_of_multithreading.3F"></a><a name="how-does-compaction-make-use-of-multithreading"></a> How does compaction make use of multithreading?</h5>
<p>The parallel compactor adds an initial exploration phase to the compaction process, which scans and splits the content tree
into multiple parts to be processed simultaneously. For this to be efficient, the tree is only expanded until a pre-defined
(currently 10,000) number of nodes is reached.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compacting with 8 threads.
TarMK GC #2: exploring content tree to find subtrees for parallel compaction.
TarMK GC #2: target node count for expansion is 10000.
TarMK GC #2: found 1 nodes at depth 0.
TarMK GC #2: found 3 nodes at depth 1.
TarMK GC #2: found 48 nodes at depth 2.
TarMK GC #2: found 663 nodes at depth 3.
TarMK GC #2: found 66944 nodes at depth 4.
</code></pre></div></section><section>
<h5><a name="How_does_compaction_work_with_concurrent_writes.3F"></a><a name="how-does-compaction-works-with-concurrent-writes"></a> How does compaction work with concurrent writes?</h5>
<p>When compaction runs as part of online garbage collection, it has to work concurrently with the rest of the system.
This means that, while compaction tries to copy useful data to the new generation, concurrent commits to the repository are writing data to the old generation.
To cope with this, compaction tries to catch up with concurrent writes by incorporating their changes into the new generation.</p>
<p>When compaction first tries to setup the new generation, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction cycle 0 completed in 6.580 min (394828 ms). Compacted 3e3b35d3-2a15-43bc-a422-7bd4741d97a5.0000002a to 348b9500-0d67-46c5-a683-3ea8b0e6c21c.000012c0
</code></pre></div>
<p>The message shows how long it took to compact the data to the new generation.
It also prints the record identifiers of the two head states.
The head state on the left belongs to the previous generation, the one on the right to the new.</p>
<p>If concurrent commits are detected, compaction tries to incorporate those changes in the new generation.
In this case, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction detected concurrent commits while compacting. Compacting these commits. Cycle 1 of 5
</code></pre></div>
<p>This message means that a new compaction cycle is automatically started.
Compaction will try to incorporate new changes for a certain amount of cycles, where the exact amount of cycles is a configuration option.
After every compaction cycle, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction cycle 1 completed in 6.580 min (394828 ms). Compacted 4d22b170-f8b7-406b-a2fc-45bf782440ac.00000065 against 3e3b35d3-2a15-43bc-a422-7bd4741d97a5.0000002a to 72e60037-f917-499b-a476-607ea6f2735c.00000d0d
</code></pre></div>
<p>This message contains three record identifiers instead of two.
This is because the initial state that was being compacted evolved into a different one due to the concurrent commits.
The message makes clear that the concurrent changes referenced from the first record identifier, up to the changes referenced from the second identifier, where moved to the new generation and are now referenced from third identifier.</p>
<p>If the system is under heavy load and too many concurrent commits are generated, compaction might fail to catch up. In this case, a message like the following is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction gave up compacting concurrent commits after 5 cycles.
</code></pre></div>
<p>The message means that compaction tried to compact the repository data to the new generation for five times, but every time there were concurrent changes that prevented compaction from completion.
To prevent the system from being too overloaded with background activity, compaction stopped itself after the configured amount of cycles.</p>
<p>At this point the system can be configured to obtain exclusive access of the system and force compaction to complete.
This means that if compaction gave up after the configured number of cycles, it would take full control over the repository and block concurrent writes.
If the system is configured to behave this way, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: trying to force compact remaining commits for 60 seconds. Concurrent commits to the store will be blocked.
</code></pre></div>
<p>If, after taking exclusive control of the repository for the specified amount of time, compaction completes successfully, the following message will be printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction succeeded to force compact remaining commits after 56.7 s (56722 ms).
</code></pre></div>
<p>Sometimes the amount of time allocated to the compaction phase in exclusive mode is not enough.
It might happen that compaction is not able to complete its work in the allocated time.
If this happens, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction failed to force compact remaining commits after 6.580 min (394828 ms). Most likely compaction didn't get exclusive access to the store.
</code></pre></div>
<p>Even if compaction takes exclusive access to the repository, it can still be interrupted.
In this case, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: compaction failed to force compact remaining commits after 6.580 min (394828 ms). Compaction was cancelled: ${REASON}.
</code></pre></div>
<p>The placeholder <code>${REASON}</code> will be substituted with a more detailed description of the reason why compaction was stopped.</p></section><section>
<h5><a name="When_did_clean-up_start.3F"></a><a name="when-did-cleanup-start"></a> When did clean-up start?</h5>
<p>When the cleanup phase of the garbage collection process starts, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: cleanup started.
</code></pre></div></section><section>
<h5><a name="Was_cleanup_cancelled.3F"></a><a name="was-cleanup-cancelled"></a> Was cleanup cancelled?</h5>
<p>If cleanup is cancelled, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: cleanup interrupted
</code></pre></div>
<p>There is no way to cancel cleanup manually.
The only time cleanup can be cancel is when shutting down the repository.</p></section><section>
<h5><a name="When_did_cleanup_complete.3F"></a><a name="when-did-cleanup-complete"></a> When did cleanup complete?</h5>
<p>When cleanup completes, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: cleanup completed in 16.23 min (974079 ms). Post cleanup size is 10.4 GB (10392082944 bytes) and space reclaimed 84.5 GB (84457663488 bytes).
</code></pre></div>
<p>The message includes the time the cleanup phase took to complete, both in a human readable format and in milliseconds.
Next the final size of the repository is shown, followed by the amount of space that was reclaimed during the cleanup phase.
Both the final size and the reclaimed space are shown in human readable form and in bytes.</p></section><section>
<h5><a name="What_happened_during_cleanup.3F"></a><a name="what-happened-during-cleanup"></a> What happened during cleanup?</h5>
<p>The first thing cleanup does is printing out the current size of the repository with a message similar to the following.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #1: current repository size is 89.3 GB (89260786688 bytes)
</code></pre></div>
<p>After that, the cleanup phase will iterate through every TAR file and figure out which segments are still in use and which ones can be reclaimed.
After the cleanup phase scanned the repository, TAR files are purged of unused segments.
In some cases, a TAR file would end up containing no segments at all.
In this case, the TAR file is marked for deletion and the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>TarMK GC #2: cleanup marking files for deletion: data00000a.tar
</code></pre></div>
<p>Please note that this message doesn't mean that cleanup will physically remove the file right now.
The file is only being marked as deletable.
Another background task will periodically kick in and remove unused files from disk.
When this happens, the following message is printed.</p>

<div class="source"><pre class="prettyprint"><code>Removed files data00000a.tar,data00001a.tar,data00002a.tar
</code></pre></div>
<p>The output of this message can vary.
It depends on the amount of segments that were cleaned up, on how many TAR files were emptied and on how often the background activity removes unused files.</p></section></section><section>
<h4><a name="Monitoring"></a><a name="monitoring"></a> Monitoring</h4>
<p>The Segment Store exposes certain pieces of information via JMX.
This allows clients to easily access some statistics about the Segment Store, and connect the Segment Store to whatever monitoring infrastructure is in place.
Moreover, JMX can be useful to execute some low-level operations in a manual fashion.</p>
<ul>

<li>Each session exposes an <a href="#SessionMBean">SessionMBean</a> instance, which contains counters like the number and rate of reads and writes to the session.</li>
<li>The <a href="#RepositoryStatsMBean">RepositoryStatsMBean</a> exposes endpoints to monitor the number of open sessions, the session login rate, the overall read and write load across all sessions, the overall read and write timings across all sessions and overall load and timings for queries and observation.</li>
<li>The <a href="#SegmentNodeStoreStatsMBean">SegmentNodeStoreStatsMBean</a> exposes endpoints to monitor commits: number and rate, number of queued commits and queuing times.</li>
<li>The <a href="#FileStoreStatsMBean">FileStoreStatsMBean</a> exposes endpoints reflecting the amount of data written to disk, the number of tar files on disk and the total footprint on disk.</li>
<li>The <a href="#SegmentRevisionGarbageCollection">SegmentRevisionGarbageCollection</a> MBean tracks statistics about garbage collection.</li>
</ul><section>
<h5><a name="SessionMBean"></a> SessionMBean</h5>
<p>Each session exposes an <code>SessionMBean</code> instance, which contains counters like the number and rate of reads and writes to the session:</p>
<ul>

<li>

<p><b>getInitStackTrace (string)</b>
A stack trace from where the session was acquired.</p>
</li>
<li>

<p><b>AuthInfo (AuthInfo)</b>
The <code>AuthInfo</code> instance for the user associated with the session.</p>
</li>
<li>

<p><b>LoginTimeStamp (string)</b>
The time stamp from when the session was acquired.</p>
</li>
<li>

<p><b>LastReadAccess (string)</b>
The time stamp from the last read access</p>
</li>
<li>

<p><b>ReadCount (long)</b>
The number of read accesses on this session</p>
</li>
<li>

<p><b>ReadRate (double)</b>
The read rate in number of reads per second on this session</p>
</li>
<li>

<p><b>LastWriteAccess (string)</b>
The time stamp from the last write access</p>
</li>
<li>

<p><b>WriteCount (long)</b>
The number of write accesses on this session</p>
</li>
<li>

<p><b>WriteRate (double)</b>
The write rate in number of writes per second on this session</p>
</li>
<li>

<p><b>LastRefresh (string)</b>
The time stamp from the last refresh on this session</p>
</li>
<li>

<p><b>RefreshStrategy (string)</b>
The refresh strategy of the session</p>
</li>
<li>

<p><b>RefreshPending (boolean)</b>
A boolean indicating whether the session will be refreshed on next access.</p>
</li>
<li>

<p><b>RefreshCount (long)</b>
The number of refresh operations on this session</p>
</li>
<li>

<p><b>RefreshRate (double)</b>
The refresh rate in number of refreshes per second on this session</p>
</li>
<li>

<p><b>LastSave (string)</b>
The time stamp from the last save on this session</p>
</li>
<li>

<p><b>SaveCount (long)</b>
The number of save operations on this session</p>
</li>
<li>

<p><b>SaveRate (double)</b>
The save rate in number of saves per second on this session</p>
</li>
<li>

<p><b>SessionAttributes (string[])</b>
The attributes associated with the session</p>
</li>
<li>

<p><b>LastFailedSave (string)</b>
The stack trace of the last exception that occurred during a save operation</p>
</li>
<li>

<p><b>refresh</b>
Refresh this session.</p>
</li>
</ul></section><section>
<h5><a name="RepositoryStatsMBean"></a> RepositoryStatsMBean</h5>
<p>The <code>RepositoryStatsMBean</code> exposes endpoints to monitor the number of open sessions, the session login rate, the overall read and write load across all sessions, the overall read and write timings across all sessions and overall load and timings for queries and observation.</p>
<ul>

<li>

<p><b>SessionCount (CompositeData)</b>
Number of currently logged in sessions.</p>
</li>
<li>

<p><b>SessionLogin (CompositeData)</b>
Number of calls sessions that have been logged in.</p>
</li>
<li>

<p><b>SessionReadCount (CompositeData)</b>
Number of read accesses through any session.</p>
</li>
<li>

<p><b>SessionReadDuration (CompositeData)</b>
Total time spent reading from sessions in nano seconds.</p>
</li>
<li>

<p><b>SessionReadAverage (CompositeData)</b>
Average time spent reading from sessions in nano seconds. This is the sum of all read durations divided by the number of reads in the respective time period.</p>
</li>
<li>

<p><b>SessionWriteCount (CompositeData)</b>
Number of write accesses through any session.</p>
</li>
<li>

<p><b>SessionWriteDuration (CompositeData)</b>
Total time spent writing to sessions in nano seconds.</p>
</li>
<li>

<p><b>SessionWriteAverage (CompositeData)</b>
Average time spent writing to sessions in nano seconds. This is the sum of all write durations divided by the number of writes in the respective time period.</p>
</li>
<li>

<p><b>QueryCount()</b>
Number of queries executed.</p>
</li>
<li>

<p><b>QueryDuration (CompositeData)</b>
Total time spent evaluating queries in milli seconds.</p>
</li>
<li>

<p><b>QueryAverage (CompositeData)</b>
Average time spent evaluating queries in milli seconds. This is the sum of all query durations divided by the number of queries in the respective time period.</p>
</li>
<li>

<p><b>ObservationEventCount (CompositeData)</b>
Total number of observation {@code Event} instances delivered to all observation listeners.</p>
</li>
<li>

<p><b>ObservationEventDuration (CompositeData)</b>
Total time spent processing observation events by all observation listeners in nano seconds.</p>
</li>
<li>

<p><b>ObservationEventAverage</b>
Average time spent processing observation events by all observation listeners in nano seconds. This is the sum of all observation durations divided by the number of observation events in the respective time period.</p>
</li>
<li>

<p><b>ObservationQueueMaxLength (CompositeData)</b>
Maximum length of observation queue in the respective time period.</p>
</li>
</ul></section><section>
<h5><a name="SegmentNodeStoreStatsMBean"></a> SegmentNodeStoreStatsMBean</h5>
<p>The <code>SegmentNodeStoreStatsMBean</code> exposes endpoints to monitor commits: number and rate, number of queued commits and queuing times.</p>
<ul>

<li>

<p><b>CommitsCount (CompositeData)</b>
Time series of the number of commits</p>
</li>
<li>

<p><b>QueuingCommitsCount (CompositeData)</b>
Time series of the number of commits queuing</p>
</li>
<li>

<p><b>CommitTimes (CompositeData)</b>
Time series of the commit times</p>
</li>
<li>

<p><b>QueuingTimes (CompositeData)</b>
Time series of the commit queuing times</p>
</li>
</ul></section><section>
<h5><a name="FileStoreStatsMBean"></a> FileStoreStatsMBean</h5>
<p>The <code>FileStoreStatsMBean</code> exposes endpoints reflecting the amount of data written to disk, the number of tar files on disk and the total footprint on disk.</p>
<ul>

<li>

<p><b>ApproximateSize (long)</b>
An approximate disk footprint of the Segment Store.</p>
</li>
<li>

<p><b>TarFileCount (int)</b>
The number of tar files of the Segment Store.</p>
</li>
<li>

<p><b>WriteStats (CompositeData)</b>
Time series of the writes to repository</p>
</li>
<li>

<p><b>RepositorySize (CompositeData)</b>
Time series of the writes to repository</p>
</li>
<li>

<p><b>StoreInfoAsString (string)</b>
A human readable descriptive representation of the values exposed by this MBean.</p>
</li>
<li>

<p><b>JournalWriteStatsAsCount (long)</b>
Number of writes to the journal of this Segment Store.</p>
</li>
<li>

<p><b>JournalWriteStatsAsCompositeData (CompositeData)</b>
Time series of the writes to the journal of this Segment Store.</p>
</li>
</ul></section><section>
<h5><a name="SegmentRevisionGarbageCollection_MBean"></a><a name="SegmentRevisionGarbageCollection"></a> SegmentRevisionGarbageCollection MBean</h5>
<p>The <code>SegmentRevisionGarbageCollection</code> MBean tracks statistics about garbage collection.
Some of the statistics are specific to specific phases of the garbage collection process, others are more widely applicable.
This MBean also exposes management operations to start and cancel garbage collection and options that can influence the outcome of garbage collection.
You should use this MBean with great care.</p>
<p>The following options are collectively called &#x201c;garbage collection options&#x201d;, since they are used to tweak the behaviour of the garbage collection process.
These options are readable and writable, but they take effect only at the start of the next garbage collection process.</p>
<ul>

<li><b>PausedCompaction (boolean)</b>
Determines if garbage collection is paused.
If this value is set to <code>true</code>, garbage collection will not be performed.
Compaction will be effectively skipped even if invoked manually or by scheduled maintenance tasks.</li>
<li><b>RetryCount (int)</b>
Determines how many completion attempts the compaction phase should try before giving up.
This parameter influences the behaviour of the compaction phase when concurrent writes are detected.</li>
<li><b>ForceTimeout (int)</b>
The amount of time (in seconds) the compaction phase can take exclusive control of the repository.
This parameter is used only if compaction is configured to take exclusive control of the repository instead of giving up after too many concurrent writes.</li>
<li><b>RetainedGenerations (int)</b>
How many generations should be preserved when cleaning up the Segment Store.
When the cleanup phase runs, only the latest <code>RetainedGenerations</code> generations are kept intact.
Older generations will be deleted. <i>Deprecated</i>: as of Oak 1.8 this value is fixed to 2 generations and cannot be modified.</li>
<li><b>GcSizeDeltaEstimation (long)</b>
The size (in bytes) of new content added to the repository since the end of the last garbage collection that would trigger another garbage collection run.
This parameter influences the behaviour of the estimation phase.</li>
<li><b>EstimationDisabled (boolean)</b>
Determines if the estimation phase is disabled.
If this parameter is set to <code>true</code>, the estimation phase will be skipped and compaction will run unconditionally.</li>
<li><b>GCType (&#x201c;FULL&#x201d; or &#x201c;TAIL&#x201d;)</b>
Determines the type of the garbage collection that should run when invoking the <code>startRevisionGC</code> operation.</li>
<li><b>RevisionGCProgressLog (long)</b>
The number of processed nodes after which a progress message is logged. <code>-1</code> indicates no logging.</li>
<li><b>MemoryThreshold (int)</b>
A number between <code>0</code> and <code>100</code> that represents the percentage of heap memory that should always be free during compaction.
If the amount of free memory falls below the provided percentage, compaction will be interrupted.</li>
</ul>
<p>The following options are read-only and expose runtime statistics about the garbage collection process.</p>
<ul>

<li><b>LastCompaction (string)</b>
The formatted timestamp of the end of the last successful compaction phase.</li>
<li><b>LastCleanup (string)</b>
The formatted timestamp of the end of the last cleanup phase.</li>
<li><b>LastRepositorySize (long)</b>
The size of the repository (in bytes) after the last cleanup phase.</li>
<li><b>LastReclaimedSize (long)</b>
The amount of data (in bytes) that was reclaimed during the last cleanup phase.</li>
<li><b>LastError (string)</b>
The last error encountered during compaction, in a human readable form.</li>
<li><b>LastLogMessage (string)</b>
The last log message produced during garbage collection.</li>
<li><b>Status (string)</b>
The current status of the garbage collection process.
This property can assume the values <code>idle</code>, <code>estimation</code>, <code>compaction</code>, <code>compaction-retry-N</code> (where <code>N</code> is the number of the current retry iteration), <code>compaction-force-compact</code> and <code>cleanup</code>.</li>
<li><b>RevisionGCRunning (boolean)</b>
Indicates whether online revision garbage collection is currently running.</li>
<li><b>CompactedNodes (long)</b>
The number of compacted nodes during the previous garbage collection</li>
<li><b>EstimatedCompactableNodes (long)</b>
The estimated number of nodes to compact during the next garbage collection. <code>-1</code> indicates an estimated value is not available.</li>
<li><b>EstimatedRevisionGCCompletion (int)</b>
Estimated percentage completed for the current garbage collection run. <code>-1</code> indicates an estimated percentage is not available.</li>
</ul>
<p>The <code>SegmentRevisionGarbageCollection</code> MBean also exposes the following management operations.</p>
<ul>

<li><b>cancelRevisionGC</b>
If garbage collection is currently running, schedule its cancellation.
The garbage collection process will be interrupted as soon as it's safe to do so without losing data or corrupting the system.
If garbage collection is not running, this operation has no effect.</li>
<li><b>startRevisionGC</b>
Start garbage collection.
If garbage collection is already running, this operation has no effect.</li>
</ul></section></section></section></section><section>
<h2><a name="Tools"></a><a name="tools"></a> Tools</h2>
<p>Oak Segment Tar exposes a number of command line tools that can be used to perform different tasks on the repository.</p>
<p>The tools are exposed as sub-commands of <a class="externalLink" href="https://github.com/apache/jackrabbit-oak/tree/trunk/oak-run">Oak Run</a>.
The following sections assume that you have built this module or that you have a compiled version of it.</p><section>
<h3><a name="Remote_Segment_Stores"></a><a name="remote-segment-stores"></a> Remote Segment Stores</h3>
<p>Besides the local storage in TAR files (previously known as TarMK), support for remote Segment Store(s) was introduced in Apache Oak. For connecting to a remote Segment Store, a <code>cloud-prefix:URI</code> argument needs to be provided. This applies wherever a <code>PATH</code> to the Segment Store was needed.</p>
<p><b>Connection Instructions</b>:</p>
<ul>

<li>

<p><b>Microsoft Azure</b> The <code>cloud-prefix</code> for MS Azure is <code>az</code>, therefore a valid connection argument would be <code>az:https://myaccount.blob.core.windows.net/container/repository</code>, where the part after <code>:</code> is the Azure URL identifier for the <i>repository</i> directory inside the specified <i>container</i> of the <i>myaccount</i> Azure storage account. Default authentication to Microsoft Entra ID with service principal credentials supplied via <code>AZURE_CLIENT_ID</code>, <code>AZURE_CLIENT_SECRET</code> and <code>AZURE_TENANT_ID</code> environment variables will be attempted first. If the former environment variables are not provided, default authentication with secret key provided as <code>AZURE_SECRET_KEY</code> will be attempted.</p>
</li>
<li>

<p><b>Amazon AWS</b> The <code>cloud-prefix</code> for Amazon AWS is <code>aws</code>, therefore a valid connection argument would be <code>aws:bucket;root_directory;journal_table;lock_table</code> where the part after <code>:</code> defines the <i>root_directory</i> inside the specified <i>bucket</i> in S3 and the <i>journal_table</i> and <i>lock_table</i> tables within DynamoDB services. The other portion to connect to AWS is the credentials which will be supplied by placing a credentials file with ~/.aws folder.</p>
</li>
</ul></section><section>
<h3><a name="Segment-Copy"></a><a name="segment-copy"></a> Segment-Copy</h3>

<div class="source"><pre class="prettyprint"><code>java -jar oak-run.jar segment-copy SOURCE DESTINATION [--last &lt;REV_COUNT&gt;] [--flat] [--append] [--max-size-gb &lt;MAX_SIZE_GB&gt;]
</code></pre></div>
<p>The <code>segment-copy</code> command allows the &#x201c;translation&#x201d; of the Segment Store at <code>SOURCE</code> from one persistence type (e.g. local TarMK Segment Store) to a different persistence type (e.g. remote Azure or AWS Segment Store), saving the resulted Segment Store at <code>DESTINATION</code>.
Unlike a sidegrade peformed with <code>oak-upgrade</code> (see <a href="#a....migration.md">Repository Migration</a>) which includes only the current head state, this translation includes <b>all previous revisions persisted in the Segment Store</b>, therefore retaining the entire history.
If <code>--last</code> option is present, the tool will start with the most recent revision and will copy at most &lt;REV_COUNT&gt; journal revisions.</p>
<p><code>SOURCE</code> must be a valid path/uri to an existing Segment Store.
<code>DESTINATION</code> must be a valid path/uri for the resulting Segment Store.</p>
<p>Both are specified as <code>PATH | cloud-prefix:URI</code>.
Please refer to the <a href="#remote-segment-stores">Remote Segment Stores</a> section for details on how to correctly specify connection URIs.</p>
<p>The optional <code>--last [Integer]</code> argument can be used to control the maximum number of revisions to be copied from the journal (default is 1).</p>
<p>The optional <code>--flat</code> argument can be specified for allowing the copy process to write the segments at <code>DESTINATION</code> in a flat hierarchy, that is without writing them in tar archives.</p>
<p>The optional <code>--append</code> argument can be specified for running segment copy in append mode. This causes existing segments in <code>DESTINATION</code> to be skipped instead of overwritten.</p>
<p>The optional <code>--max-size-gb &lt;MAX_SIZE_GB&gt;</code> argument can be used for specifying to copy up to <code>MAX_SIZE_GB</code> segments from <code>SOURCE</code>.</p>
<p>To enable logging during segment copy a Logback configuration file has to be injected via the <code>logback.configurationFile</code> property.</p><section><section>
<h5><a name="Example"></a>Example</h5>
<p>The following command uses <code>logback-segment-copy.xml</code> to configure Logback logging for segment-copy to the console.</p>

<div class="source"><pre class="prettyprint"><code>java -Dlogback.configurationFile=logback-segment-copy.xml -jar oak-run.jar segment-copy cloud-prefix:URI some/local/path
</code></pre></div>
<p>logback-segment-copy.xml:</p>

<div class="source"><pre class="prettyprint"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration scan=&quot;true&quot;&gt;

  &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;logger name=&quot;org.apache.jackrabbit.oak.segment.azure.tool.SegmentStoreMigrator&quot; level=&quot;INFO&quot;/&gt;

  &lt;root level=&quot;warn&quot;&gt;
    &lt;appender-ref ref=&quot;console&quot;/&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</code></pre></div></section></section></section><section>
<h3><a name="Backup"></a><a name="backup"></a> Backup</h3>

<div class="source"><pre class="prettyprint"><code>java -jar oak-run.jar backup ORIGINAL BACKUP 
</code></pre></div>
<p>The <code>backup</code> tool performs a backup of a Segment Store <code>ORIGINAL</code> and saves it to the folder <code>BACKUP</code>.
<code>ORIGINAL</code> must be the path to an existing, valid Segment Store.
<code>BACKUP</code> must be a valid path to a folder on the file system.
If <code>BACKUP</code> doesn't exist, it will be created.
If <code>BACKUP</code> exists, it must be a path to an existing, valid Segment Store.</p>
<p>The tool assumes that the <code>ORIGINAL</code> Segment Store doesn't use an external Blob Store.
If this is the case, it's necessary to set the <code>oak.backup.UseFakeBlobStore</code> system property to <code>true</code> on the command line as shown below.</p>

<div class="source"><pre class="prettyprint"><code>java -Doak.backup.UseFakeBlobStore=true -jar oak-run.jar backup ...
</code></pre></div>
<p>When a backup is performed, if <code>BACKUP</code> points to an existing Segment Store, only the content that is different from <code>ORIGINAL</code> is copied.
This is similar to an incremental backup performed at the level of the content.
When an incremental backup is performed, the tool will automatically try to cleanup eventual garbage from the <code>BACKUP</code> Segment Store.</p></section><section>
<h3><a name="Restore"></a><a name="restore"></a> Restore</h3>

<div class="source"><pre class="prettyprint"><code>java -jar oak-run.jar restore ORIGINAL BACKUP
</code></pre></div>
<p>The <code>restore</code> tool restores the state of the <code>ORIGINAL</code> Node Store from a previous backup <code>BACKUP</code>.
This tool is the counterpart of <code>backup</code>.</p></section><section>
<h3><a name="Check"></a><a name="check"></a> Check</h3>

<div class="source"><pre class="prettyprint"><code>java -jar oak-run.jar check PATH [--mmap] [--journal JOURNAL] [--notify SECS] [--bin] [--last &lt;REV_COUNT&gt;] [--head] [--checkpoints all | cp1[,cp2,..,cpn]]  [--filter PATH1[,PATH2,..,PATHn]] [--io-stats]
</code></pre></div>
<p>The <code>check</code> tool inspects an existing Segment Store at <code>PATH</code> for eventual inconsistencies.
The algorithm implemented by this tool traverses every revision in the journal, from the most recent to the oldest, stopping at the first consistent occurence. The actual nodes and properties are traversed, verifying that every piece of data is reachable and undamaged. If <code>--last</code> option is present, the tool will start with the most recent revision and will go back in the history at most <code>&lt;REV_COUNT&gt;</code> revisions. Moreover, if <code>--head</code> and <code>--checkpoints</code> options are used, the scope of the traversal can be limited to head state and/or a subset of checkpoints. A deep scan of the content tree, traversing every node and every property will be performed by default. The default scope includes head state and all checkpoints.</p>
<p>The optional <code>--mmap [Boolean]</code> argument can be used to control the file access mode. Set
to <code>true</code> for memory mapped access and <code>false</code> for file access (default is <code>true</code>).</p>
<p>If the <code>--journal</code> option is specified, the tool will use the journal file at <code>JOURNAL</code> instead of picking up the one contained in <code>PATH</code>.
<code>JOURNAL</code> must be a path to a valid journal file for the Segment Store.</p>
<p>If the <code>--notify</code> option is specified, the tool will print progress information messages every <code>SECS</code> seconds.
If not specified, progress information messages will be disabled.
If <code>SECS</code> equals <code>0</code>, every progress information message is printed.</p>
<p>If the <code>--bin</code> option is specified, the tool will scan the full content of binary properties.
If not specified, the binary properties will not be traversed.
The <code>--bin</code> option has no effect on binary properties stored in an external Blob Store.</p>
<p>The optional <code>--last [Integer]</code> argument can be used to control the maximum number of revisions to be verified (default is <code>1</code>).</p>
<p>The optional <code>--fail-fast</code> argument can be used to stop the check as soon as an inconsistency is found. If not specified, the tool will continue to check the entire journal.</p>
<p>If the <code>--head</code> option is specified, the tool will scan <b>only</b> the head state, ignoring any available checkpoints.</p>
<p>If the <code>--checkpoints</code> option is specified, the tool will scan <b>only</b> the specified checkpoints, ignoring the head state. At least one argument is expected with this option; multiple arguments need to be comma-separated.
The checkpoints will be traversed in the same order as they were specified. In order to scan all checkpoints, the correct argument for this option is <code>all</code> (i.e. <code>--checkpoints all</code>).</p>
<p>As mentioned in the paragraph above, by default, both head state and all checkpoints will be checked. In other words, this is equivalent to having both options, <code>--head</code> and <code>--checkpoints all</code>, specified.</p>
<p>If the <code>--filter</code> option is specified, the tool will traverse only the absolute paths specified as arguments.
At least one argument is expected with this option; multiple arguments need to be comma-separated.
The paths will be traversed in the same order as they were specified.</p>
<p>The filtering applies to both head state and/or checkpoints, depending on the scope of the scan. For example, <code>--head --filter PATH1</code> will limit the traversal to <code>PATH1</code> under head state, <code>--checkpoints cp1 --filter PATH2</code> will limit the traversal to <code>PATH2</code> under <code>cp1</code>, while <code>--filter PATH3</code> will limit it to <code>PATH3</code>, <b>for both head state and all checkpoints</b>.
If the option is not specified, the full traversal of the repository (rooted at <code>/</code>) will be performed.</p>
<p>If the <code>--io-stats</code> option is specified, the tool will print some statistics about the I/O operations performed during the execution of the check command.
This option is optional and is disabled by default.</p>
<p>The optional <code>--persistent-cache-path PERSISTENT_CACHE_PATH</code> argument allows to specify the path for the persistent disk cache. <code>PERSISTENT_CACHE_PATH</code> must be a valid path.</p>
<p>The optional <code>--persistent-cache-size-gb &lt;PERSISTENT_CACHE_SIZE_GB&gt;</code> argument allows to limit the maximum size of the persistent disk cache to <code>&lt;PERSISTENT_CACHE_SIZE_GB&gt;</code>. If not specified, the default size will be limited to <code>50</code> GB.</p></section><section>
<h3><a name="Compact"></a><a name="compact"></a> Compact</h3>

<div class="source"><pre class="prettyprint"><code>java -jar oak-run.jar compact [--force] [--mmap] [--tail] [--compactor] [--threads] SOURCE [--target-path DESTINATION] [--persistent-cache-path PERSISTENT_CACHE_PATH] [--persistent-cache-size-gb &lt;PERSISTENT_CACHE_SIZE_GB&gt;]
</code></pre></div>
<p>The <code>compact</code> command performs offline compaction of the local/remote Segment Store at <code>SOURCE</code>.
<code>SOURCE</code> must be a valid path/uri to an existing Segment Store. Currently, Azure Segment Store and AWS Segment Store the supported remote Segment Stores.
Please refer to the <a href="#remote-segment-stores">Remote Segment Stores</a> section for details on how to correctly specify connection URIs.</p>
<p>With the optional <code>--tail</code> flag, only tail compaction is performed instead of the full repository.</p>
<p>If the optional <code>--force</code> flag is set, the tool ignores a non-matching Segment Store version. <i>CAUTION</i>: this will upgrade the Segment Store to the
latest version, which is incompatible with older versions. <i>There is no way to downgrade
an accidentally upgraded Segment Store</i>.</p>
<p>The optional <code>--mmap [Boolean]</code> argument can be used to control the file access mode. Set
to <code>true</code> for memory mapped access and <code>false</code> for file access. If not specified, memory
mapped access is used on 64-bit systems and file access is used on 32-bit systems. On
Windows, regular file access is always enforced and this option is ignored.</p>
<p>The optional <code>--compactor [String]</code> argument can be used to pick the compactor type to be used. Valid choices are <i>classic</i>, <i>diff</i> and <i>parallel</i>. While <i>classic</i> is slower, it might be more stable, due to lack of optimisations employed by the <i>diff</i> compactor which compacts the checkpoints on top of each other and the <i>parallel</i> compactor, which additionally divides the repository into multiple parts to process in parallel. If not specified, <i>parallel</i> compactor is used.</p>
<p>The optional <code>--threads [Integer]</code> argument specifies the number of threads to use for compaction. This is only applicable to the <i>parallel</i> compactor. If not specified, this defaults to the number of available processors.</p>
<p>In order to speed up offline compaction for remote Segment Stores, three new options were introduced for configuring the destination segment store where compacted archives will be written and also to configure a persistent disk cache for speeding up segments reading during compaction. All three options detailed below <b>apply only for remote Segment Stores</b>.</p>
<p>The required <code>--target-path DESTINATION</code> argument allows to specify a destination where compacted segments will be written. <code>DESTINATION</code> must be a valid path/uri for the new compacted Segment Store.</p>
<p>The required <code>--persistent-cache-path PERSISTENT_CACHE_PATH</code> argument allows to specify the path for the persistent disk cache. <code>PERSISTENT_CACHE_PATH</code> must be a valid path.</p>
<p>The optional <code>--persistent-cache-size-gb &lt;PERSISTENT_CACHE_SIZE_GB&gt;</code> argument allows to limit the maximum size of the persistent disk cache to <code>&lt;PERSISTENT_CACHE_SIZE_GB&gt;</code>. If not specified, the default size will be limited to <code>50</code> GB.</p>
<p>To enable logging during offline compaction a Logback configuration file has to be injected
via the <code>logback.configurationFile</code> property. In addition the <code>compaction-progress-log</code>
property controls the number of compacted nodes that will be logged. The default value is 150000.</p><section><section>
<h5><a name="Example"></a>Example</h5>
<p>The following command uses <code>logback-compaction.xml</code> to configure Logback logging compaction
progress every 1000 nodes to the console.</p>

<div class="source"><pre class="prettyprint"><code>java -Dlogback.configurationFile=logback-compaction.xml -Dcompaction-progress-log=1000 -jar oak-run.jar compact /path/to/segmenstore
</code></pre></div>
<p>logback-compaction.xml:</p>

<div class="source"><pre class="prettyprint"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration scan=&quot;true&quot;&gt;
  
  &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;
  
  &lt;logger name=&quot;org.apache.jackrabbit.oak.segment.file.FileStore&quot; level=&quot;INFO&quot;/&gt;
  
  &lt;root level=&quot;warn&quot;&gt;
    &lt;appender-ref ref=&quot;console&quot; /&gt;
  &lt;/root&gt;
&lt;/configuration&gt; 
</code></pre></div></section></section></section><section>
<h3><a name="Debug"></a><a name="debug"></a> Debug</h3>

<div class="source"><pre class="prettyprint"><code>java -jar oak-run.jar debug PATH
java -jar oak-run.jar debug PATH ITEMS...
</code></pre></div>
<p>The <code>debug</code> command prints diagnostic information about a Segment Store or individual Segment Store items.</p>
<p><code>PATH</code> is mandatory and must be a valid path to an existing Segment Store.
If only the path is specified - as in the first example above - only general debugging information about the Segment Store are printed.</p>
<p><code>ITEMS</code> is a sequence of one or more TAR file name, segment ID, node record ID or range of node record ID.
If one or more items are specified - as in the second example above - general debugging information about the segment store are not printed.
Instead, detailed information about the specified items are shown.</p>
<p>A TAR file is specified by its name.
Every string in <code>ITEMS</code> ending in<code>.tar</code> is assumed to be a name of a TAR file.</p>
<p>A segment ID is specified by its UUID representation, e.g. <code>333dc24d-438f-4cca-8b21-3ebf67c05856</code>.</p>
<p>A node record ID is specified by a concatenation of a UUID and a record number, e.g. <code>333dc24d-438f-4cca-8b21-3ebf67c05856:12345</code>.
The record ID must point to a valid node record.
A node record ID can be optionally followed by path, like <code>333dc24d-438f-4cca-8b21-3ebf67c05856:12345/path/to/child</code>.
When a node record ID is provided, the tool will print information about the node record pointed by it.
If a path is specified, the tool will additionally print information about every child node identified by that path.</p>
<p>A node record ID range is specified by a pair of record IDs separated by a hyphen (<code>-</code>), e.g. <code>333dc24d-438f-4cca-8b21-3ebf67c05856:12345-46116fda-7a72-4dbc-af88-a09322a7753a:67890</code>.
Both record IDs must point to valid node records.
The pair of record IDs can be followed by a path, like <code>333dc24d-438f-4cca-8b21-3ebf67c05856:12345-46116fda-7a72-4dbc-af88-a09322a7753a:67890/path/to/child</code>.
When a node record ID range is specified, the tool will perform a diff between the two nodes pointed by the record IDs, optionally following the provided path.
The result of the diff will be printed in JSOP format.</p></section><section>
<h3><a name="IOTrace"></a><a name="iotrace"></a> IOTrace</h3>

<div class="source"><pre class="prettyprint"><code>java -jar oak-run.jar iotrace PATH --trace DEPTH|BREADTH [--depth DEPTH] [--mmap MMAP] [--output OUTPUT] [--path PATH] [--segment-cache SEGMENT_CACHE] 

usage: iotrace path/to/segmentstore &lt;options&gt;
Option (* = required)      Description
---------------------      -----------
--count &lt;Integer&gt;          Number of paths to access Applies to RANDOM (default: 1000)
--depth &lt;Integer&gt;          Maximal depth of the traversal. Applies to BREADTH, DEPTH (default: 5)
--mmap &lt;Boolean&gt;           use memory mapping for the file store (default: true)
--output &lt;File&gt;            output file where the IO trace is written to (default: iotrace.csv)
--path &lt;String&gt;            starting path for the traversal. Applies to BREADTH, DEPTH (default: /root)
--paths &lt;File&gt;             file containing list of paths to traverse. Applies to RANDOM (default: paths.txt)
--seed &lt;Long&gt;              Seed for generating random numbers. Applies to RANDOM (default: 0)
--segment-cache &lt;Integer&gt;  size of the segment cache in MB (default: 256)
* --trace &lt;Traces&gt;         type of the traversal. Either of [DEPTH, BREADTH, RANDOM]
</code></pre></div>
<p>The <code>iotrace</code> command collects IO traces of read accesses to the segment store's back-end
(e.g. disk). Traffic patterns can be specified via the <code>--trace</code> option. Permissible values
are <code>DEPTH</code> for depth first traversal, <code>BREADTH</code> for breadth first traversal and <code>RANDOM</code> for
random access. The <code>--depth</code> option limits the maximum number of levels traversed.
The <code>--path</code> option specifies the node where traversal starts (from the super root).
The <code>--mmap</code> and <code>--segment-cache</code> options configure memory mapping and segment cache size
of the segment store, respectively.
The <code>--paths</code> option specifies the list of paths to access. The file must contain a single path
per line.
The <code>--seed</code> option specifies the seed to used when randomly choosing a paths.<br />
The <code>--output</code> options specifies the file where the IO trace is stored. IO traces are stored in
CSV format of the following form:</p>

<div class="source"><pre class="prettyprint"><code>timestamp,file,segmentId,length,elapsed
1522147945084,data01415a.tar,f81378df-b3f8-4b25-0000-00000002c450,181328,171849
1522147945096,data01415a.tar,f81378df-b3f8-4b25-0000-00000002c450,181328,131272
1522147945097,data01415a.tar,f81378df-b3f8-4b25-0000-00000002c450,181328,142766
</code></pre></div></section><section>
<h3><a name="Diff"></a><a name="diff"></a> Diff</h3>

<div class="source"><pre class="prettyprint"><code>java -jar oak-run.jar tarmkdiff [--output OUTPUT] --list PATH
java -jar oak-run.jar tarmkdiff [--output OUTPUT] [--incremental] [--path NODE] [--ignore-snfes] --diff REVS PATH
</code></pre></div>
<p>The <code>diff</code> command prints content diffs between revisions in the Segment Store at <code>PATH</code>.</p>
<p>The <code>--output</code> option instructs the command to print its output to the file <code>OUTPUT</code>.
If this option is not specified, the tool will print to a <code>.log</code> file augmented with the current timestamp.
The default file will be saved in the current directory.</p>
<p>If the <code>--list</code> option is specified, the command just prints a list of revisions available in the Segment Store.
This is equivalent to the first command line specification in the example above.</p>
<p>If the <code>--list</code> option is not specified, <code>tarmkdiff</code> prints one or more content diff between a pair of revisions.
In this case, the command line specification is the second in the example above.</p>
<p>The <code>--diff</code> option specifies an interval of revisions <code>REVS</code>.
The interval is specified by a couple of revisions separated by two dots, e.g. <code>333dc24d-438f-4cca-8b21-3ebf67c05856:12345..46116fda-7a72-4dbc-af88-a09322a7753a:67890</code>.
In place of any of the two revisions, the placeholder <code>head</code> can be used.
The <code>head</code> placeholder is substituted (in a case-insensitive way) to the most recent revision in the Segment Store.</p>
<p>The <code>--path</code> option can be used to restrict the diff to a portion of the content tree.
The value <code>NODE</code> must be a valid path in the content tree.</p>
<p>If the flag <code>--incremental</code> is specified, the output will contain an incremental diff between every pair of successive revisions occurring in the interval specified with <code>--diff</code>.
This parameter is useful if you are interested in every change in content between every commit that happened in a specified range.</p>
<p>The <code>--ignore-snfes</code> flag can be used in combination with <code>--incremental</code> to ignore errors that might occur while generating the incremental diff because of damaged or too old content.
If this flag is not specified and an error occurs while generating the incremental diff, the tool stops immediately and reports the error.</p></section><section>
<h3><a name="History"></a><a name="history"></a> History</h3>

<div class="source"><pre class="prettyprint"><code>java -jar oak-run.jar history [--journal JOURNAL] [--path NODE] [--depth DEPTH] PATH
</code></pre></div>
<p>The <code>history</code> command shows how the content of a node or of a sub-tree changed over time in the Segment Store at <code>PATH</code>.</p>
<p>The history of the node is computed based on the revisions reported by the journal in the Segment Store.
If a different set of revisions needs to be used, it is possible to specify a custom journal file by using the <code>--journal</code> option.
If this option is used, <code>JOURNAL</code> must be a path to a valid journal file.</p>
<p>The <code>--path</code> parameter specifies the node whose history will be printed.
If not specified, the history of the root node will be printed.
<code>NODE</code> must be a valid path to a node in the Segment Store.</p>
<p>The <code>--depth</code> parameter determines if the content of a single node should be printed, or if the content of the sub-tree rooted at that node should be printed instead.
<code>DEPTH</code> must be a positive integer specifying how deep the printed content should be.
If this option is not specified, the depth is assumed to be <code>0</code>, i.e. only information about the node will be printed.</p></section><section>
<h3><a name="Recover_journal"></a><a name="recover-journal"></a> Recover journal</h3>

<div class="source"><pre class="prettyprint"><code>java -jar oak-run.jar recover-journal [--help] PATH
</code></pre></div>
<p>The <code>recover-journal</code> command rebuilds a journal by scanning the content of the Segment Store at <code>PATH</code>.</p>
<p>The command performs the following steps:</p>
<ul>

<li>It scans the content of all segments for potential head states.</li>
<li>It sorts the found head states from older to newer.</li>
<li>It checks the consistency of the found head states until the first consistent head state is found.</li>
</ul>
<p>During the consistency check, some segments might be missing.
The command outputs a stack trace on stderr every time it finds a new missing segment.
If the command finds a segment missing more than once, further stack traces are suppressed.</p>
<p>The last revision in the recovered journal is guaranteed to have a consistent head state.
For the sake of speed, checkpoints are <b>not</b> checked.
Moreover, since the consistency check stops as soon as it finds a consistent head state, older revisions in the recovered journal might still be inconsistent.
For a deeper analysis of the consistency of the recovered journal, see the <code>check</code> command.</p>
<p>The <code>recover-journal</code> command is not destructive and tries its best to leave the Segment Store folder in a consistent, usable state.
Before creating a new journal, the old one is backed up in the Segment Store folder as <code>journal.log.bak.XXX</code>, where <code>XXX</code> is a monotonically increasing, three-digit number.
Only after the backup of the old journal is successful, the command installs the recovered journal as the canonical <code>journal.log</code>.
If any error occurs in the process, the command will roll the old journal back and discard the backup.</p></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
<p>&#169; 2012-2024
<a href="https://www.apache.org/">The Apache Software Foundation</a> &vert; <a href="https://privacy.apache.org/policies/privacy-policy-public.html">Privacy Policy</a>
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>